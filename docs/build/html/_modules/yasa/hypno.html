<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>yasa.hypno &#8212; yasa 0.6.3 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/yasa_128x128.png"></span>
          yasa</a>
        <span class="navbar-text navbar-version pull-left"><b>0.6.3</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../quickstart.html">Quickstart</a></li>
                <li><a href="../../faq.html">FAQ</a></li>
                <li><a href="../../changelog.html">What's new</a></li>
                <li><a href="../../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for yasa.hypno</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file contains several helper functions to manipulate sleep staging</span>
<span class="sd">(hypnogram) data. The default hypnogram format in YASA is a one dimensional</span>
<span class="sd">integer array where:</span>

<span class="sd">* -2  = Unscored</span>
<span class="sd">* -1  = Artefact / Movement</span>
<span class="sd">* 0   = Wake</span>
<span class="sd">* 1   = N1 sleep</span>
<span class="sd">* 2   = N2 sleep</span>
<span class="sd">* 3   = N3 sleep</span>
<span class="sd">* 4   = REM sleep</span>

<span class="sd">For more details, please refer to the following references:</span>

<span class="sd">- Iber, C. (2007). The AASM manual for the scoring of sleep and</span>
<span class="sd">associated events: rules, terminology and technical specifications.</span>
<span class="sd">American Academy of Sleep Medicine.</span>

<span class="sd">- Silber, M. H., Ancoli-Israel, S., Bonnet, M. H., Chokroverty, S.,</span>
<span class="sd">Grigg-Damberger, M. M., Hirshkowitz, M., … Iber, C. (2007). The visual scoring</span>
<span class="sd">of sleep in adults. Journal of Clinical Sleep Medicine: JCSM: Official</span>
<span class="sd">Publication of the American Academy of Sleep Medicine, 3(2), 121–131.</span>

<span class="sd">- Combrisson, E., Vallat, R., Eichenlaub, J.-B., O’Reilly, C., Lajnef, T.,</span>
<span class="sd">Guillot, A., … Jerbi, K. (2017). Sleep: An Open-Source Python Software for</span>
<span class="sd">Visualization, Analysis, and Staging of Sleep Data. Frontiers in</span>
<span class="sd">Neuroinformatics, 11, 60. https://doi.org/10.3389/fninf.2017.00060</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">.io</span> <span class="kn">import</span> <span class="n">set_log_level</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;hypno_str_to_int&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_int_to_str&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_consolidate_stages&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_upsample_to_sf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_upsample_to_data&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hypno_find_periods&quot;</span><span class="p">,</span>
    <span class="s2">&quot;load_profusion_hypno&quot;</span><span class="p">,</span>
    <span class="s2">&quot;simulate_hypno&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;yasa&quot;</span><span class="p">)</span>


<span class="c1">#############################################################################</span>
<span class="c1"># STR &lt;--&gt; INT CONVERSION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="hypno_str_to_int"><a class="viewcode-back" href="../../generated/yasa.hypno_str_to_int.html#yasa.hypno_str_to_int">[docs]</a><span class="k">def</span> <span class="nf">hypno_str_to_int</span><span class="p">(</span>
    <span class="n">hypno</span><span class="p">,</span>
    <span class="n">mapping_dict</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;wake&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;n1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;s1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;n2&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;s2&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;n3&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;s3&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;s4&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;rem&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;art&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;mt&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;uns&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;nd&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a string hypnogram array to integer.</span>

<span class="sd">    [&#39;W&#39;, &#39;N2&#39;, &#39;N2&#39;, &#39;N3&#39;, &#39;R&#39;] ==&gt; [0, 2, 2, 3, 4]</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    mapping_dict : dict</span>
<span class="sd">        The mapping dictionnary, in lowercase. Note that this function is essentially a wrapper</span>
<span class="sd">        around :py:meth:`pandas.Series.map`.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The corresponding integer hypnogram.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)),</span> <span class="s2">&quot;Not an array.&quot;</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">))</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">hypno</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span> <span class="s2">&quot;Hypno contains numeric values.&quot;</span>
    <span class="k">return</span> <span class="n">hypno</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span><span class="o">.</span><span class="n">values</span></div>


<div class="viewcode-block" id="hypno_int_to_str"><a class="viewcode-back" href="../../generated/yasa.hypno_int_to_str.html#yasa.hypno_int_to_str">[docs]</a><span class="k">def</span> <span class="nf">hypno_int_to_str</span><span class="p">(</span>
    <span class="n">hypno</span><span class="p">,</span> <span class="n">mapping_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;N1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;N2&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;N3&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;Art&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;Uns&quot;</span><span class="p">}</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an integer hypnogram array to a string array.</span>

<span class="sd">    [0, 2, 2, 3, 4] ==&gt; [&#39;W&#39;, &#39;N2&#39;, &#39;N2&#39;, &#39;N3&#39;, &#39;R&#39;]</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    mapping_dict : dict</span>
<span class="sd">        The mapping dictionnary. Note that this function is essentially a wrapper around</span>
<span class="sd">        :py:meth:`pandas.Series.map`.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The corresponding integer hypnogram.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)),</span> <span class="s2">&quot;Not an array.&quot;</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">hypno</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span><span class="o">.</span><span class="n">values</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># UPSAMPLING</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="hypno_upsample_to_sf"><a class="viewcode-back" href="../../generated/yasa.hypno_upsample_to_sf.html#yasa.hypno_upsample_to_sf">[docs]</a><span class="k">def</span> <span class="nf">hypno_upsample_to_sf</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hypno</span><span class="p">,</span> <span class="n">sf_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Upsample the hypnogram to a given sampling frequency.</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    sf_hypno : float</span>
<span class="sd">        The current sampling frequency of the hypnogram, in Hz, e.g.</span>

<span class="sd">        * 1/30 = 1 value per each 30 seconds of EEG data,</span>
<span class="sd">        * 1 = 1 value per second of EEG data</span>
<span class="sd">    sf_data : float</span>
<span class="sd">        The desired sampling frequency of the hypnogram, in Hz (e.g. 100 Hz, 256 Hz, ...)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The hypnogram, upsampled to ``sf_data``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">sf_data</span> <span class="o">/</span> <span class="n">sf_hypno</span>
    <span class="k">assert</span> <span class="n">sf_hypno</span> <span class="o">&lt;=</span> <span class="n">sf_data</span><span class="p">,</span> <span class="s2">&quot;sf_hypno must be less than sf_data.&quot;</span>
    <span class="k">assert</span> <span class="n">repeats</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span> <span class="s2">&quot;sf_hypno / sf_data must be a whole number.&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">),</span> <span class="n">repeats</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">hypno_fit_to_data</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Crop or pad the hypnogram to fit the length of data.</span>

<span class="sd">    Hypnogram and data MUST have the SAME sampling frequency.</span>

<span class="sd">    This is an internal function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    data : np.array_like or mne.io.Raw</span>
<span class="sd">        1D or 2D EEG data. Can also be a MNE Raw object, in which case data and sf will be</span>
<span class="sd">        automatically extracted.</span>
<span class="sd">    sf : float, optional</span>
<span class="sd">        The sampling frequency of data AND the hypnogram.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Hypnogram, with the same number of samples as data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if data is an MNE raw object</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">times</span>  <span class="c1"># 1D array and does not require to preload data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Hypno must be 1D.&quot;</span>
    <span class="n">npts_hyp</span> <span class="o">=</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span>
    <span class="n">npts_data</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Support for 2D data</span>
    <span class="k">if</span> <span class="n">npts_hyp</span> <span class="o">&lt;</span> <span class="n">npts_data</span><span class="p">:</span>
        <span class="c1"># Hypnogram is shorter than data</span>
        <span class="n">npts_diff</span> <span class="o">=</span> <span class="n">npts_data</span> <span class="o">-</span> <span class="n">npts_hyp</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dur_diff</span> <span class="o">=</span> <span class="n">npts_diff</span> <span class="o">/</span> <span class="n">sf</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Hypnogram is SHORTER than data by </span><span class="si">%.2f</span><span class="s2"> seconds. &quot;</span>
                <span class="s2">&quot;Padding hypnogram with last value to match data.size.&quot;</span> <span class="o">%</span> <span class="n">dur_diff</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Hypnogram is SHORTER than data by </span><span class="si">%i</span><span class="s2"> samples. &quot;</span>
                <span class="s2">&quot;Padding hypnogram with last value to match data.size.&quot;</span> <span class="o">%</span> <span class="n">npts_diff</span>
            <span class="p">)</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npts_diff</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">npts_hyp</span> <span class="o">&gt;</span> <span class="n">npts_data</span><span class="p">:</span>
        <span class="c1"># Hypnogram is longer than data</span>
        <span class="n">npts_diff</span> <span class="o">=</span> <span class="n">npts_hyp</span> <span class="o">-</span> <span class="n">npts_data</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dur_diff</span> <span class="o">=</span> <span class="n">npts_diff</span> <span class="o">/</span> <span class="n">sf</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Hypnogram is LONGER than data by </span><span class="si">%.2f</span><span class="s2"> seconds. &quot;</span>
                <span class="s2">&quot;Cropping hypnogram to match data.size.&quot;</span> <span class="o">%</span> <span class="n">dur_diff</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Hypnogram is LONGER than data by </span><span class="si">%i</span><span class="s2"> samples. &quot;</span>
                <span class="s2">&quot;Cropping hypnogram to match data.size.&quot;</span> <span class="o">%</span> <span class="n">npts_diff</span>
            <span class="p">)</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npts_data</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">hypno</span>


<div class="viewcode-block" id="hypno_upsample_to_data"><a class="viewcode-back" href="../../generated/yasa.hypno_upsample_to_data.html#yasa.hypno_upsample_to_data">[docs]</a><span class="k">def</span> <span class="nf">hypno_upsample_to_data</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hypno</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Upsample an hypnogram to a given sampling frequency and fit the</span>
<span class="sd">    resulting hypnogram to corresponding EEG data, such that the hypnogram</span>
<span class="sd">    and EEG data have the exact same number of samples.</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    sf_hypno : float</span>
<span class="sd">        The current sampling frequency of the hypnogram, in Hz, e.g.</span>

<span class="sd">        * 1/30 = 1 value per each 30 seconds of EEG data,</span>
<span class="sd">        * 1 = 1 value per second of EEG data</span>
<span class="sd">    data : array_like or :py:class:`mne.io.BaseRaw`</span>
<span class="sd">        1D or 2D EEG data. Can also be a :py:class:`mne.io.BaseRaw`, in which</span>
<span class="sd">        case ``data`` and ``sf_data`` will be automatically extracted.</span>
<span class="sd">    sf_data : float</span>
<span class="sd">        The sampling frequency of ``data``, in Hz (e.g. 100 Hz, 256 Hz, ...).</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    verbose : bool or str</span>
<span class="sd">        Verbose level. Default (False) will only print warning and error</span>
<span class="sd">        messages. The logging levels are &#39;debug&#39;, &#39;info&#39;, &#39;warning&#39;, &#39;error&#39;,</span>
<span class="sd">        and &#39;critical&#39;. For most users the choice is between &#39;info&#39;</span>
<span class="sd">        (or ``verbose=True``) and warning (``verbose=False``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The hypnogram, upsampled to ``sf_data`` and cropped/padded to ``max(data.shape)``.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If the upsampled ``hypno`` is shorter / longer than ``max(data.shape)``</span>
<span class="sd">        and therefore needs to be padded/cropped respectively. This output can be disabled by</span>
<span class="sd">        passing ``verbose=&#39;ERROR&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">times</span>
    <span class="n">hypno_up</span> <span class="o">=</span> <span class="n">hypno_upsample_to_sf</span><span class="p">(</span><span class="n">hypno</span><span class="o">=</span><span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hypno</span><span class="o">=</span><span class="n">sf_hypno</span><span class="p">,</span> <span class="n">sf_data</span><span class="o">=</span><span class="n">sf_data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hypno_fit_to_data</span><span class="p">(</span><span class="n">hypno</span><span class="o">=</span><span class="n">hypno_up</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="n">sf_data</span><span class="p">)</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># HYPNO LOADING</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="load_profusion_hypno"><a class="viewcode-back" href="../../generated/yasa.load_profusion_hypno.html#yasa.load_profusion_hypno">[docs]</a><span class="k">def</span> <span class="nf">load_profusion_hypno</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a Compumedics Profusion hypnogram (.xml).</span>

<span class="sd">    The Compumedics Profusion hypnogram format is one of the two hypnogram</span>
<span class="sd">    formats found in the `National Sleep Research Resource (NSRR)</span>
<span class="sd">    &lt;https://sleepdata.org/&gt;`_ website. For more details on the format,</span>
<span class="sd">    please refer to</span>
<span class="sd">    https://github.com/nsrr/edf-editor-translator/wiki/Compumedics-Annotation-Format</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename with full path.</span>
<span class="sd">    replace : bool</span>
<span class="sd">        If True, the integer values will be mapped to YASA default, i.e.</span>
<span class="sd">        0 for Wake, 1 for N1, 2 for N2, 3 for N3 / S4 and 4 for REM.</span>
<span class="sd">        Note that the native profusion format is identical except for REM</span>
<span class="sd">        sleep which is marked as 5.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : 1D array (n_epochs, )</span>
<span class="sd">        Hypnogram, with one value per 30 second epochs.</span>
<span class="sd">    sf_hyp : float</span>
<span class="sd">        Sampling frequency of the hypnogram. Default is 1 / 30 Hz.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note that an alternative is to use the `xmltodict` library:</span>
    <span class="c1"># &gt;&gt;&gt; with open(fname) as in_file:</span>
    <span class="c1"># &gt;&gt;&gt;   xml = in_file.read()</span>
    <span class="c1"># &gt;&gt;&gt; epoch_length = xml[&#39;EpochLength&#39;]</span>
    <span class="c1"># &gt;&gt;&gt; hypno = np.array(xml[&#39;SleepStages&#39;][&#39;SleepStage&#39;], dtype=&#39;int&#39;)</span>
    <span class="c1"># &gt;&gt;&gt; xml = xmltodict.parse(xml, process_namespaces=True)[&#39;CMPStudyConfig&#39;]</span>
    <span class="c1"># &gt;&gt;&gt; annotations = pd.DataFrame(xml[&#39;ScoredEvents&#39;][&#39;ScoredEvent&#39;])</span>
    <span class="c1"># &gt;&gt;&gt; annotations[&quot;Start&quot;] = annotations[&quot;Start&quot;].astype(float)</span>
    <span class="c1"># &gt;&gt;&gt; annotations[&quot;Duration&quot;] = annotations[&quot;Duration&quot;].astype(float)</span>
    <span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
    <span class="n">epoch_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="n">sf_hyp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">epoch_length</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">root</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
        <span class="n">hypno</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
        <span class="c1"># Stage 4 --&gt; 3 and REM --&gt; 4</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="mi">4</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hyp</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># PERIODS &amp; CYCLES</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="hypno_find_periods"><a class="viewcode-back" href="../../generated/yasa.hypno_find_periods.html#yasa.hypno_find_periods">[docs]</a><span class="k">def</span> <span class="nf">hypno_find_periods</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">sf_hypno</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="s2">&quot;5min&quot;</span><span class="p">,</span> <span class="n">equal_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find sequences of consecutive values exceeding a certain duration in hypnogram.</span>

<span class="sd">    .. versionadded:: 0.6.2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        A 1D array with the sleep stages (= hypnogram). The dtype can be anything (int, bool, str).</span>
<span class="sd">        More generally, this can be any vector for which you wish to find runs of</span>
<span class="sd">        consecutive items.</span>
<span class="sd">    sf_hypno : float</span>
<span class="sd">        The current sampling frequency of ``hypno``, in Hz, e.g. 1/30 = 1 value per each 30 seconds</span>
<span class="sd">        of EEG data, 1 = 1 value per second of EEG data.</span>
<span class="sd">    threshold : str</span>
<span class="sd">        This function will only keep periods that exceed a certain duration (default &#39;5min&#39;), e.g.</span>
<span class="sd">        &#39;5min&#39;, &#39;15min&#39;, &#39;30sec&#39;, &#39;1hour&#39;. To disable thresholding, use &#39;0sec&#39;.</span>
<span class="sd">    equal_length : bool</span>
<span class="sd">        If True, the periods will all have the exact duration defined</span>
<span class="sd">        in threshold. That is, periods that are longer than the duration threshold will be divided</span>
<span class="sd">        into sub-periods of exactly the length of ``threshold``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    periods : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Output dataframe</span>

<span class="sd">        * ``values`` : The value in hypno of the current period</span>
<span class="sd">        * ``start`` : The index of the start of the period in hypno</span>
<span class="sd">        * ``length`` : The duration of the period, in number of samples</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Let&#39;s assume that we have an hypnogram where sleep = 1 and wake = 0. There is one value per</span>
<span class="sd">    minute, and therefore the sampling frequency of the hypnogram is 1 / 60 sec (~0.016 Hz).</span>

<span class="sd">    &gt;&gt;&gt; import yasa</span>
<span class="sd">    &gt;&gt;&gt; hypno = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; yasa.hypno_find_periods(hypno, sf_hypno=1/60, threshold=&quot;0min&quot;)</span>
<span class="sd">       values  start  length</span>
<span class="sd">    0       0      0      11</span>
<span class="sd">    1       1     11       3</span>
<span class="sd">    2       0     14       2</span>
<span class="sd">    3       1     16       9</span>
<span class="sd">    4       0     25       2</span>

<span class="sd">    This gives us the start and duration of each sequence of consecutive values in the hypnogram.</span>
<span class="sd">    For example, the first row tells us that there is a sequence of 11 consecutive 0 starting at</span>
<span class="sd">    the first index of hypno.</span>

<span class="sd">    Now, we may want to keep only periods that are longer than a specific threshold,</span>
<span class="sd">    for example 5 minutes:</span>

<span class="sd">    &gt;&gt;&gt; yasa.hypno_find_periods(hypno, sf_hypno=1/60, threshold=&quot;5min&quot;)</span>
<span class="sd">       values  start  length</span>
<span class="sd">    0       0      0      11</span>
<span class="sd">    1       1     16       9</span>

<span class="sd">    Only the two sequences that are longer than 5 minutes (11 minutes and 9 minutes respectively)</span>
<span class="sd">    are kept. Feel free to play around with different values of threshold!</span>

<span class="sd">    This function is not limited to binary arrays, e.g.</span>

<span class="sd">    &gt;&gt;&gt; hypno = [0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; yasa.hypno_find_periods(hypno, sf_hypno=1/60, threshold=&quot;2min&quot;)</span>
<span class="sd">       values  start  length</span>
<span class="sd">    0       0      0       4</span>
<span class="sd">    1       2      5       6</span>
<span class="sd">    2       0     11       3</span>

<span class="sd">    Lastly, using ``equal_length=True`` will further divide the periods into segments of the</span>
<span class="sd">    same duration, i.e. the duration defined in ``threshold``:</span>

<span class="sd">    &gt;&gt;&gt; hypno = [0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; yasa.hypno_find_periods(hypno, sf_hypno=1/60, threshold=&quot;2min&quot;, equal_length=True)</span>
<span class="sd">       values  start  length</span>
<span class="sd">    0       0      0       2</span>
<span class="sd">    1       0      2       2</span>
<span class="sd">    2       2      5       2</span>
<span class="sd">    3       2      7       2</span>
<span class="sd">    4       2      9       2</span>
<span class="sd">    5       0     11       2</span>

<span class="sd">    Here, the first period of 4 minutes of consecutive 0 is further divided into 2 periods of</span>
<span class="sd">    exactly 2 minutes. Next, the sequence of 6 consecutive 2 is further divided into 3 periods of</span>
<span class="sd">    2 minutes. Lastly, the last value in the sequence of 3 consecutive 0 at the end of the array is</span>
<span class="sd">    removed to keep only a segment of 2 exactly minutes. In other words, the remainder of the</span>
<span class="sd">    division of a given segment by the desired duration is discarded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert the threshold to number of samples</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Threshold must be a string, e.g. &#39;5min&#39;, &#39;30sec&#39;, &#39;15min&#39;&quot;</span>
    <span class="n">thr_sec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
    <span class="n">thr_samp</span> <span class="o">=</span> <span class="n">sf_hypno</span> <span class="o">*</span> <span class="n">thr_sec</span>
    <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">thr_samp</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
        <span class="n">thr_samp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">thr_samp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The selected threshold does not result in an whole number of samples (&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">thr_sec</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> seconds * </span><span class="si">{</span><span class="n">sf_hypno</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> Hz = </span><span class="si">{</span><span class="n">thr_samp</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> samples)&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Find run starts</span>
    <span class="c1"># https://gist.github.com/alimanfoo/c5977e87111abe8127453b21204c1065</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)),</span> <span class="s2">&quot;hypno must be an array.&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">loc_run_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">loc_run_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">loc_run_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">run_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">loc_run_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Find run values</span>
    <span class="n">run_values</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">loc_run_start</span><span class="p">]</span>
    <span class="c1"># Find run lengths</span>
    <span class="n">run_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run_starts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">run_values</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">run_starts</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="n">run_lengths</span><span class="p">})</span>

    <span class="c1"># Remove runs that are shorter than threshold</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thr_samp</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">equal_length</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seq</span>

    <span class="c1"># Divide into epochs of equal length</span>
    <span class="k">assert</span> <span class="n">thr_samp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Threshold must be non-zero if using equal_length=True.&quot;</span>
    <span class="n">new_seq</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">seq</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">],</span> <span class="n">thr_samp</span><span class="p">)</span>
        <span class="n">new_start</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">quotient</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">quotient</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">])</span>
                <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_start</span><span class="p">)</span>
                <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thr_samp</span><span class="p">)</span>
                <span class="n">new_start</span> <span class="o">+=</span> <span class="n">thr_samp</span>
                <span class="n">quotient</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;values&quot;</span><span class="p">])</span>
            <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">])</span>
            <span class="n">new_seq</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">])</span>

    <span class="n">new_seq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">new_seq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_seq</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># STAGE CONVERSION</span>
<span class="c1">#############################################################################</span>


<span class="k">def</span> <span class="nf">hypno_consolidate_stages</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">n_stages_in</span><span class="p">,</span> <span class="n">n_stages_out</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reduce the number of stages in a hypnogram to match actigraphy or wearables.</span>

<span class="sd">    For example, a standard 5-stage hypnogram (W, N1, N2, N3, REM) could be consolidated</span>
<span class="sd">    to a hypnogram more common with actigraphy (W, Light, Deep, REM).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The sleep staging (hypnogram) 1D array.</span>
<span class="sd">    n_stages_in : int</span>
<span class="sd">        Number of possible stages of ``hypno``, where:</span>

<span class="sd">        - 5 stages - 0=Wake, 1=N1, 2=N2, 3=N3, 4=REM</span>
<span class="sd">        - 4 stages - 0=Wake, 2=Light, 3=Deep, 4=REM</span>
<span class="sd">        - 3 stages - 0=Wake, 2=NREM, 4=REM</span>
<span class="sd">        - 2 stages - 0=Wake, 1=Sleep</span>

<span class="sd">        .. note:: The default YASA values for Unscored (-2) and Artefact (-1) are always allowed.</span>
<span class="sd">    n_stages_out : int</span>
<span class="sd">        Similar to ``n_stages_in`` but for output. Must be higher than ``n_stages_out``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        The hypnogram, with stages converted to ``n_stages_out`` staging scheme.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)),</span> <span class="s2">&quot;hypno must be array_like&quot;</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">n_stages_in</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="s2">&quot;n_stages_in must be 3, 4, or 5&quot;</span>
    <span class="k">assert</span> <span class="n">n_stages_out</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s2">&quot;n_stages_in must be 2, 3, or 4&quot;</span>
    <span class="k">assert</span> <span class="n">n_stages_out</span> <span class="o">&lt;</span> <span class="n">n_stages_in</span><span class="p">,</span> <span class="s2">&quot;n_stages_out must be lower than n_stages_in&quot;</span>

    <span class="c1"># Change sleep codes where applicable.</span>
    <span class="k">if</span> <span class="n">n_stages_out</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Consolidate all Sleep</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
    <span class="k">elif</span> <span class="n">n_stages_out</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># Consolidate N1/N2/N3 or Light/Deep into NREM</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
    <span class="k">elif</span> <span class="n">n_stages_out</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># Consolidate N1/N2 into Light</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">}</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">hypno</span>


<span class="c1">#############################################################################</span>
<span class="c1"># SIMULATION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="simulate_hypno"><a class="viewcode-back" href="../../generated/yasa.simulate_hypno.html#yasa.simulate_hypno">[docs]</a><span class="k">def</span> <span class="nf">simulate_hypno</span><span class="p">(</span><span class="n">tib</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">30</span><span class="p">,</span> <span class="n">n_stages</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">trans_probas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init_probas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate a hypnogram based on transition probabilities.</span>

<span class="sd">    Current implentation is a naive Markov model. The initial stage of a hypnogram</span>
<span class="sd">    is generated using probabilites from ``init_probas`` and then subsequent stages</span>
<span class="sd">    are generated from a Markov sequence based on ``trans_probas``.</span>

<span class="sd">    .. important:: The Markov simulation model is not meant to accurately portray sleep</span>
<span class="sd">        macroarchitecture and should only be used for testing or other unique purposes.</span>

<span class="sd">    .. versionadded:: 0.6.3</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tib : int</span>
<span class="sd">        Total duration of the hypnogram (i.e., time in bed), expressed in minutes.</span>
<span class="sd">        Returned hypnogram will be slightly shorter if ``tib`` in seconds is not</span>
<span class="sd">        evenly divisible by ``sf``.</span>

<span class="sd">        .. seealso:: :py:func:`yasa.sleep_statistics`</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    n_stages : int</span>
<span class="sd">        Staging scheme of returned hypnogram. Input should follow 5-stage scheme but can</span>
<span class="sd">        be converted to lower scheme if desired.</span>

<span class="sd">        .. seealso:: :py:func:`yasa.hypno_consolidate_stages`</span>
<span class="sd">    trans_probas : :py:class:`pandas.DataFrame` or None</span>
<span class="sd">        Transition probability matrix where each cell is a transition probability</span>
<span class="sd">        between sleep stages of consecutive *epochs*.</span>

<span class="sd">        ``trans_probas`` is a `right stochastic matrix</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Stochastic_matrix&gt;`_, i.e. each row sums to 1.</span>

<span class="sd">        If None (default), use transition probabilites from Metzner et al., 2021 [Metzner2021]_.</span>
<span class="sd">        If :py:class:`pandas.DataFrame`, must have &quot;from&quot;-stages as indices and</span>
<span class="sd">        &quot;to&quot;-stages as columns. Indices and columns must follow YASA integer</span>
<span class="sd">        hypnogram convention (W = 0, N = 1, ...). Unscored/Artefact stages are not allowed.</span>

<span class="sd">        .. note:: Transition probability matrices should indicate the transition</span>
<span class="sd">            probability between *epochs* (i.e., probability of the next epoch) and</span>
<span class="sd">            not simply stage (i.e., probability of non-similar stage).</span>

<span class="sd">        .. seealso:: Return value from :py:func:`yasa.transition_matrix`</span>
<span class="sd">    init_probas : :py:class:`pandas.Series` or None</span>
<span class="sd">        Probabilites of each stage to initialize random walk.</span>
<span class="sd">        If None (default), initialize with &quot;From&quot;-Wake row of ``trans_probas``.</span>
<span class="sd">        If :py:class:`pandas.Series`, indices must be stages following YASA integer</span>
<span class="sd">        hypnogram convention (see ``trans_probas``).</span>
<span class="sd">    seed : int or None</span>
<span class="sd">        Random seed for generating Markov sequence.</span>
<span class="sd">        If an integer number is provided, the random hypnogram will be predictable.</span>
<span class="sd">        This argument is required if reproducible results are desired.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hypno : np.ndarray</span>
<span class="sd">        Hypnogram containing simulated sleep stages.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Default transition probabilities can be found in the ``traMat_Epoch.npy`` file of</span>
<span class="sd">    Supplementary Information for Metzner et al., 2021 [Metzner2021]_ (rounded values</span>
<span class="sd">    are viewable in Figure 5b). Please cite this work if these probabilites are used</span>
<span class="sd">    for publication.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Metzner2021] Metzner, C., Schilling, A., Traxdorf, M., Schulze, H., &amp; Krausse, P.</span>
<span class="sd">                     (2021). Sleep as a random walk: a super-statistical analysis of EEG</span>
<span class="sd">                     data across sleep stages. Communications Biology, 4.</span>
<span class="sd">                     https://doi.org/10.1038/s42003-021-02912-6</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from yasa import simulate_hypno</span>
<span class="sd">    &gt;&gt;&gt; hypno = simulate_hypno(tib=10, seed=0)</span>
<span class="sd">    &gt;&gt;&gt; print(hypno)</span>
<span class="sd">    [0 0 0 0 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2]</span>

<span class="sd">    &gt;&gt;&gt; hypno = simulate_hypno(tib=10, n_stages=2, seed=0)</span>
<span class="sd">    &gt;&gt;&gt; print(hypno)</span>
<span class="sd">    [0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]</span>

<span class="sd">    Base the data off a real subject&#39;s transition matrix.</span>

<span class="sd">    .. plot::</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; import yasa</span>
<span class="sd">        &gt;&gt;&gt; url = (</span>
<span class="sd">        &gt;&gt;&gt;     &quot;https://github.com/raphaelvallat/yasa/raw/master/&quot;</span>
<span class="sd">        &gt;&gt;&gt;     &quot;notebooks/data_full_6hrs_100Hz_hypno_30s.txt&quot;</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; hypno = np.loadtxt(url)</span>
<span class="sd">        &gt;&gt;&gt; _, probas = yasa.transition_matrix(hypno)</span>
<span class="sd">        &gt;&gt;&gt; hypno_sim = yasa.simulate_hypno(tib=360, trans_probas=probas, seed=9)</span>
<span class="sd">        &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(9, 6))</span>
<span class="sd">        &gt;&gt;&gt; yasa.plot_hypnogram(hypno, ax=ax1)</span>
<span class="sd">        &gt;&gt;&gt; yasa.plot_hypnogram(hypno_sim, ax=ax2)</span>
<span class="sd">        &gt;&gt;&gt; ax1.set_title(&quot;True hypnogram&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax2.set_title(&quot;Simulated hypnogram&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate input</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tib</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)),</span> <span class="s2">&quot;tib must be a number&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)),</span> <span class="s2">&quot;sf must be a number&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_stages</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;n_stages must be an integer&quot;</span>
    <span class="k">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">n_stages</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;n_stages must be 2, 3, 4, or 5&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seed</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;seed must be an integer &gt;= 0&quot;</span>
    <span class="k">if</span> <span class="n">trans_probas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trans_probas</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s2">&quot;trans_probas must be a pandas DataFrame&quot;</span>
    <span class="k">if</span> <span class="n">init_probas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_probas</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">),</span> <span class="s2">&quot;init_probas must be a pandas Series&quot;</span>

    <span class="c1"># Initialize random number generator</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_markov_sequence</span><span class="p">(</span><span class="n">p_init</span><span class="p">,</span> <span class="n">p_transition</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a Markov sequence based on p_init and p_transition.</span>
<span class="sd">        https://ericmjl.github.io/essays-on-data-science/machine-learning/markov-models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_init</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sequence_length</span><span class="p">:</span>
            <span class="n">p_tr</span> <span class="o">=</span> <span class="n">p_transition</span><span class="p">[</span><span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">new_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_tr</span><span class="p">))</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">trans_probas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Generate transition probability DataFrame (here, ordered W R 1 2 3)</span>
        <span class="n">trans_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="mi">11737</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">571</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">57</span><span class="p">,</span> <span class="mi">10071</span><span class="p">,</span> <span class="mi">189</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">281</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">6697</span><span class="p">,</span> <span class="mi">1661</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">253</span><span class="p">,</span> <span class="mi">272</span><span class="p">,</span> <span class="mi">1070</span><span class="p">,</span> <span class="mi">26259</span><span class="p">,</span> <span class="mi">505</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">49</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">176</span><span class="p">,</span> <span class="mi">279</span><span class="p">,</span> <span class="mi">9630</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">trans_probas</span> <span class="o">=</span> <span class="n">trans_freqs</span> <span class="o">/</span> <span class="n">trans_freqs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">trans_probas</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">trans_probas</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">init_probas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Extract Wake row of initial probabilities as a Series</span>
        <span class="n">init_probas</span> <span class="o">=</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Ensure trans_probas DataFrame and init_probas Series are in row/column order W N1 N2 N3 R</span>
    <span class="n">trans_probas</span> <span class="o">=</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">reindex</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">trans_probas</span> <span class="o">=</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">reindex</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">init_probas</span> <span class="o">=</span> <span class="n">init_probas</span><span class="o">.</span><span class="n">reindex</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;trans_proba indices must be YASA integer codes&quot;</span>
    <span class="k">assert</span> <span class="n">init_probas</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;init_probas index must be YASA integer codes&quot;</span>

    <span class="c1"># Extract probabilities as arrays</span>
    <span class="n">trans_arr</span> <span class="o">=</span> <span class="n">trans_probas</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">init_arr</span> <span class="o">=</span> <span class="n">init_probas</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="c1"># Make sure all rows sum to 1</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">trans_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">init_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Find number of *complete* epochs within TIB timeframe</span>
    <span class="n">n_epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tib</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">sf</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Generate hypnogram</span>
    <span class="n">hypno</span> <span class="o">=</span> <span class="n">_markov_sequence</span><span class="p">(</span><span class="n">init_arr</span><span class="p">,</span> <span class="n">trans_arr</span><span class="p">,</span> <span class="n">n_epochs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_stages</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">hypno_consolidate_stages</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">n_stages_in</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_stages_out</span><span class="o">=</span><span class="n">n_stages</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hypno</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-2022, Dr. Raphael Vallat, Center for Human Sleep Science, UC Berkeley.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>