<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>yasa.main &#8212; yasa 0.2.0 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/yasa_128x128.png"></span>
          yasa</a>
        <span class="navbar-text navbar-version pull-left"><b>0.2.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../api.html">Functions</a></li>
                <li><a href="../../changelog.html">What's new</a></li>
                <li><a href="../../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for yasa.main</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">YASA (Yet Another Spindle Algorithm): fast and robust detection of spindles,</span>
<span class="sd">slow-waves, and rapid eye movements from sleep EEG recordings.</span>

<span class="sd">- Author: Raphael Vallat (www.raphaelvallat.com)</span>
<span class="sd">- GitHub: https://github.com/raphaelvallat/yasa</span>
<span class="sd">- License: BSD 3-Clause License</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">mne.filter</span> <span class="k">import</span> <span class="n">filter_data</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="k">import</span> <span class="n">next_fast_len</span>


<span class="kn">from</span> <span class="nn">.numba</span> <span class="k">import</span> <span class="n">_detrend</span><span class="p">,</span> <span class="n">_rms</span>
<span class="kn">from</span> <span class="nn">.others</span> <span class="k">import</span> <span class="n">moving_transform</span><span class="p">,</span> <span class="n">trimbothstd</span><span class="p">,</span> <span class="n">_zerocrossings</span>
<span class="kn">from</span> <span class="nn">.spectral</span> <span class="k">import</span> <span class="n">stft_power</span>

<span class="c1"># Define YASA logger</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> | </span><span class="si">%(levelname)s</span><span class="s1"> | </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">datefmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%b-%y %H:%M:%S&#39;</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;yasa&#39;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;spindles_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;spindles_detect_multi&#39;</span><span class="p">,</span> <span class="s1">&#39;sw_detect&#39;</span><span class="p">,</span>
           <span class="s1">&#39;sw_detect_multi&#39;</span><span class="p">,</span> <span class="s1">&#39;rem_detect&#39;</span><span class="p">,</span> <span class="s1">&#39;get_bool_vector&#39;</span><span class="p">,</span>
           <span class="s1">&#39;get_sync_events&#39;</span><span class="p">]</span>

<span class="c1">#############################################################################</span>
<span class="c1"># HELPER FUNCTIONS</span>
<span class="c1">#############################################################################</span>


<span class="k">def</span> <span class="nf">_merge_close</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">min_distance_ms</span><span class="p">,</span> <span class="n">sf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merge events that are too close in time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : array_like</span>
<span class="sd">        Indices of supra-threshold events.</span>
<span class="sd">    min_distance_ms : int</span>
<span class="sd">        Minimum distance (ms) between two events to consider them as two</span>
<span class="sd">        distinct events</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data (Hz)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f_index : array_like</span>
<span class="sd">        Filled (corrected) Indices of supra-threshold events</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Original code imported from the Visbrain package.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert min_distance_ms</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">min_distance_ms</span> <span class="o">/</span> <span class="mf">1000.</span> <span class="o">*</span> <span class="n">sf</span>
    <span class="n">idx_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">idx_diff</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="n">idx_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">idx_diff</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="n">idx_distance</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="c1"># Fill gap between events separated with less than min_distance_ms</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                          <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bad</span><span class="p">)])</span>
        <span class="n">f_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">fill</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f_index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">index</span>


<span class="k">def</span> <span class="nf">_index_to_events</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a 2D (start, end) array into a continuous one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        2D array of indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index : array_like</span>
<span class="sd">        Continuous array of indices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Original code imported from the Visbrain package.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


<div class="viewcode-block" id="get_bool_vector"><a class="viewcode-back" href="../../generated/yasa.get_bool_vector.html#yasa.get_bool_vector">[docs]</a><span class="k">def</span> <span class="nf">get_bool_vector</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detection</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a Boolean vector given the original data and sf and</span>
<span class="sd">    a YASA&#39;s detection dataframe.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like or :py:class:`mne.io.BaseRaw`</span>
<span class="sd">        1D or 2D EEG data. Can also be :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">        in which case ``data`` and ``sf`` will be automatically extracted.</span>
<span class="sd">    sf : float</span>
<span class="sd">        The sampling frequency of ``data``.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    detection : :py:class:`pandas.DataFrame`</span>
<span class="sd">        YASA&#39;s detection dataframe returned by the</span>
<span class="sd">        :py:func:`yasa.spindles_detect`, :py:func:`yasa.sw_detect`,</span>
<span class="sd">        or :py:func:`yasa.rem_detect` functions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool_vector : :py:class:`numpy.ndarray`</span>
<span class="sd">        Array of bool indicating for each sample in data if this sample is</span>
<span class="sd">        part of a detected event (True) or not (False).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if input data is a MNE Raw object</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>  <span class="c1"># Extract sampling frequency</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span>  <span class="c1"># Convert from V to uV</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># Flatten if only one channel is present</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">detection</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s1">&#39;Start&#39;</span> <span class="ow">in</span> <span class="n">detection</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">assert</span> <span class="s1">&#39;End&#39;</span> <span class="ow">in</span> <span class="n">detection</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">bool_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># For multi-channel detection</span>
    <span class="n">multi</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="s1">&#39;Channel&#39;</span> <span class="ow">in</span> <span class="n">detection</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">chan</span> <span class="o">=</span> <span class="n">detection</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">n_chan</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">size</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">n_chan</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">multi</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chan</span><span class="p">:</span>
            <span class="n">sp_chan</span> <span class="o">=</span> <span class="n">detection</span><span class="p">[</span><span class="n">detection</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">]</span>
            <span class="n">idx_sp</span> <span class="o">=</span> <span class="n">_index_to_events</span><span class="p">(</span><span class="n">sp_chan</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">sf</span><span class="p">)</span>
            <span class="n">bool_vector</span><span class="p">[</span><span class="n">sp_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx_sp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx_sp</span> <span class="o">=</span> <span class="n">_index_to_events</span><span class="p">(</span><span class="n">detection</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">sf</span><span class="p">)</span>
        <span class="n">bool_vector</span><span class="p">[</span><span class="n">idx_sp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">bool_vector</span></div>


<div class="viewcode-block" id="get_sync_events"><a class="viewcode-back" href="../../generated/yasa.get_sync_events.html#yasa.get_sync_events">[docs]</a><span class="k">def</span> <span class="nf">get_sync_events</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;NegPeak&#39;</span><span class="p">,</span>
                    <span class="n">time_before</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">time_after</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the raw data of each detected slow-waves / spindles, after</span>
<span class="sd">    centering to a specific timepoint.</span>

<span class="sd">    This function can be used to plot an average template of the</span>
<span class="sd">    detected slow-waves / spindles.</span>

<span class="sd">    For more details, please refer to the `Jupyter notebook</span>
<span class="sd">    &lt;https://github.com/raphaelvallat/yasa/blob/master/notebooks/06_sw_detection_multi.ipynb&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like or :py:class:`mne.io.BaseRaw`</span>
<span class="sd">        1D or 2D EEG data. Can also be :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">        in which case ``data`` and ``sf`` will be automatically extracted.</span>
<span class="sd">    sf : float</span>
<span class="sd">        The sampling frequency of ``data``.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    detection : :py:class:`pandas.DataFrame`</span>
<span class="sd">        YASA&#39;s detection dataframe returned by the</span>
<span class="sd">        :py:func:`yasa.sw_detect`,</span>
<span class="sd">        :py:func:`yasa.spindles_detect`,</span>
<span class="sd">        :py:func:`yasa.sw_detect_multi`, and</span>
<span class="sd">        :py:func:`yasa.spindles_detect_multi` functions.</span>
<span class="sd">    center : str</span>
<span class="sd">        Landmark of the slow-waves / spindles to synchronize the timing on.</span>
<span class="sd">        Default is to use the negative peak.</span>
<span class="sd">    time_before : float</span>
<span class="sd">        Time (in seconds) before ``center``.</span>
<span class="sd">    time_after : float</span>
<span class="sd">        Time (in seconds) after ``center``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_sync : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Ouput long-format dataframe::</span>

<span class="sd">        &#39;Event&#39; : Event number</span>
<span class="sd">        &#39;Time&#39; : Timing of the events (in seconds)</span>
<span class="sd">        &#39;Amplitude&#39; : Raw data for event</span>
<span class="sd">        &#39;Chan&#39; : Channel (only in multi-channel detection)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if input data is a MNE Raw object</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>  <span class="c1"># Extract sampling frequency</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span>  <span class="c1"># Convert from V to uV</span>

    <span class="c1"># Safety checks</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;data must be a numpy array&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">detection</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">),</span> <span class="s1">&#39;detection must be a dataframe&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)),</span> <span class="s1">&#39;sf must be a float or an int&#39;</span>
    <span class="k">assert</span> <span class="n">center</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PosPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;NegPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="s1">&#39;MidCrossing&#39;</span><span class="p">,</span> <span class="s1">&#39;Start&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;End&#39;</span><span class="p">],</span> <span class="s1">&#39;center timepoint not recognized&#39;</span>

    <span class="k">if</span> <span class="s1">&#39;Channel&#39;</span> <span class="ow">in</span> <span class="n">detection</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="c1"># Multi-channel (recursive call)</span>
        <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Data must be 2D for multi-channel detection.&#39;</span>
        <span class="n">df_sync</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">detection</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;Channel&#39;</span><span class="p">):</span>
            <span class="n">idx_chan</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">df_tmp</span> <span class="o">=</span> <span class="n">get_sync_events</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">idx_chan</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sf</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                                     <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">time_before</span><span class="o">=</span><span class="n">time_before</span><span class="p">,</span>
                                     <span class="n">time_after</span><span class="o">=</span><span class="n">time_after</span><span class="p">)</span>
            <span class="n">df_tmp</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">df_tmp</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_chan</span>
            <span class="n">df_sync</span> <span class="o">=</span> <span class="n">df_sync</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_tmp</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Single-channel</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Data must be 1D for single-channel detection.&#39;</span>
        <span class="c1"># Define number of samples before and after the peak</span>
        <span class="k">assert</span> <span class="n">time_before</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">time_after</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="n">N_bef</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span>
        <span class="n">N_aft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_after</span><span class="p">)</span>
        <span class="c1"># Convert to integer sample indices in data</span>
        <span class="n">idx_peak</span> <span class="o">=</span> <span class="p">(</span><span class="n">detection</span><span class="p">[</span><span class="n">center</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">rng</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Utility function to create a range before and after</span>
<span class="sd">            a given value.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">N_bef</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">N_aft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

        <span class="c1"># Extract indices, data, and time vector</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx_peak</span><span class="p">)</span>
        <span class="c1"># We drop the events for which the indices exceed data</span>
        <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_rows</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compress_rows</span><span class="p">(</span><span class="n">idx_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;Time before and/or time after exceed data bounds, please &#39;</span>
                <span class="s1">&#39;lower the temporal window around center; returning None.&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">rng</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>

        <span class="c1"># Convert to dataframe</span>
        <span class="n">df_sync</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">amps</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">df_sync</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
        <span class="n">df_sync</span> <span class="o">=</span> <span class="n">df_sync</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">id_vars</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Event&#39;</span><span class="p">,</span>
                               <span class="n">value_name</span><span class="o">=</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df_sync</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># SPINDLES DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="spindles_detect"><a class="viewcode-back" href="../../generated/yasa.spindles_detect.html#yasa.spindles_detect">[docs]</a><span class="k">def</span> <span class="nf">spindles_detect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">freq_sp</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
                    <span class="n">duration</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">freq_broad</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                    <span class="n">downsample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span> <span class="mf">0.65</span><span class="p">,</span>
                    <span class="s1">&#39;rms&#39;</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">},</span> <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">coupling</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">freq_so</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Spindles detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Single-channel continuous EEG data. Unit must be uV.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The default unit of :py:class:`mne.io.BaseRaw` is Volts.</span>
<span class="sd">            Therefore, if passing data from a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">            you need to multiply the data by 1e6 to convert to micro-Volts</span>
<span class="sd">            (1 V = 1,000,000 uV), e.g.:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                data = raw.get_data() * 1e6  # Make sure that data is in uV</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data, in Hz.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage vector (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = N1 + N2 + N3 sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (1, 2, 3), meaning that the detection is applied on N1, N2 and N3</span>
<span class="sd">        sleep. This has no effect when ``hypno`` is None.</span>
<span class="sd">    freq_sp : tuple or list</span>
<span class="sd">        Spindles frequency range. Default is 12 to 15 Hz. Please note that YASA</span>
<span class="sd">        uses a FIR filter (implemented in MNE) with a 1.5Hz transition band,</span>
<span class="sd">        which means that for `freq_sp = (12, 15 Hz)`, the -6 dB points are</span>
<span class="sd">        located at 11.25 and 15.75 Hz.</span>
<span class="sd">    duration : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the spindles.</span>
<span class="sd">        Default is 0.5 to 2 seconds.</span>
<span class="sd">    freq_broad : tuple or list</span>
<span class="sd">        Broad band frequency of interest.</span>
<span class="sd">        Default is 1 to 30 Hz.</span>
<span class="sd">    min_distance : int</span>
<span class="sd">        If two spindles are closer than ``min_distance`` (in ms), they are</span>
<span class="sd">        merged into a single spindles. Default is 500 ms.</span>
<span class="sd">    downsample : boolean</span>
<span class="sd">        If True, the data will be downsampled to 100 Hz or 128 Hz (depending</span>
<span class="sd">        on whether the original sampling frequency is a multiple of 100 or 128,</span>
<span class="sd">        respectively).</span>
<span class="sd">    thresh : dict</span>
<span class="sd">        Detection thresholds::</span>

<span class="sd">            &#39;rel_pow&#39; : Relative power (= power ratio freq_sp / freq_broad).</span>
<span class="sd">            &#39;corr&#39; : Pearson correlation coefficient.</span>
<span class="sd">            &#39;rms&#39; : Mean(RMS) + 1.5 * STD(RMS).</span>

<span class="sd">        You can disable one or more threshold by putting ``None`` instead:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            thresh = {&#39;rel_pow&#39;: None, &#39;corr&#39;: 0.65, &#39;rms&#39;: 1.5}</span>
<span class="sd">            thresh = {&#39;rel_pow&#39;: None, &#39;corr&#39;: None, &#39;rms&#39;: 3}</span>
<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers spindles</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        The outliers detection is performed on all the spindles</span>
<span class="sd">        parameters with the exception of the ``Start``, ``Peak``, ``End``,</span>
<span class="sd">        and ``SOPhase`` columns.</span>
<span class="sd">        YASA uses a random seed (42) to ensure reproducible results.</span>
<span class="sd">        Note that this step will only be applied if there are more than 50</span>
<span class="sd">        detected spindles in the first place. Default to False.</span>
<span class="sd">    coupling : boolean</span>
<span class="sd">        If True, YASA will also calculate the coupling between each detected</span>
<span class="sd">        spindles and the slow-oscillation signal. The coupling is given by the</span>
<span class="sd">        phase (in radians) of the filtered slow-oscillation signal</span>
<span class="sd">        at the most prominent peak of the spindles.</span>

<span class="sd">        Importantly, since the resulting variable is expressed in radians,</span>
<span class="sd">        one should use circular statistics to calculate the mean direction</span>
<span class="sd">        and vector length:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            import pingouin as pg</span>
<span class="sd">            mean_direction = pg.circ_mean(sp[&#39;SOPhase&#39;])</span>
<span class="sd">            vector_length = pg.circ_r(sp[&#39;SOPhase&#39;])</span>

<span class="sd">        For more details, please refer to the `Jupyter notebook</span>
<span class="sd">        &lt;https://github.com/raphaelvallat/yasa/blob/master/notebooks/12_spindles-SO_coupling.ipynb&gt;`_</span>

<span class="sd">        .. versionadded:: 0.1.9</span>

<span class="sd">    freq_so : tuple or list</span>
<span class="sd">        Slow-oscillations frequency of interest. This is only relevant if</span>
<span class="sd">        ``coupling=True``. Default is 0.1 to 1.25 Hz, with a narrow transition</span>
<span class="sd">        bandwidth of 0.1 Hz.</span>

<span class="sd">        .. versionadded:: 0.1.9</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sp_params : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Ouput detection dataframe::</span>

<span class="sd">            &#39;Start&#39; : Start time of each detected spindles (in seconds)</span>
<span class="sd">            &#39;Peak&#39;: Timing of the most prominent spindles peak (in seconds)</span>
<span class="sd">            &#39;End&#39; : End time (in seconds)</span>
<span class="sd">            &#39;Duration&#39; : Duration (in seconds)</span>
<span class="sd">            &#39;Amplitude&#39; : Amplitude (in uV)</span>
<span class="sd">            &#39;RMS&#39; : Root-mean-square (in uV)</span>
<span class="sd">            &#39;AbsPower&#39; : Median absolute power (in log10 uV^2)</span>
<span class="sd">            &#39;RelPower&#39; : Median relative power (ranging from 0 to 1, in % uV^2)</span>
<span class="sd">            &#39;Frequency&#39; : Median frequency (in Hz)</span>
<span class="sd">            &#39;Oscillations&#39; : Number of oscillations (peaks)</span>
<span class="sd">            &#39;Symmetry&#39; : Symmetry index, ranging from 0 to 1</span>
<span class="sd">            &#39;SOPhase&#39;: SO phase (radians) at the most prominent spindle peak</span>
<span class="sd">            &#39;Stage&#39; : Sleep stage (only if hypno was provided)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For better results, apply this detection only on artefact-free NREM sleep.</span>

<span class="sd">    For an example on how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/01_spindles_detection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Safety check</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Wrong data dimension. Please pass 1D data.&#39;</span>
    <span class="n">freq_sp</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">freq_sp</span><span class="p">)</span>
    <span class="n">freq_broad</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">freq_broad</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">downsample</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;Downsample must be True or False.&#39;</span>

    <span class="c1"># Hypno processing</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Hypno must be one dimensional.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Hypno must have same size as data.&#39;</span>
        <span class="n">unique_hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of unique values in hypno = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">unique_hypno</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># Check include</span>
        <span class="k">assert</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;include cannot be None if hypno is given&#39;</span>
        <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">include</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">include</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;`include` must have at least one element.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">include</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hypno and include &#39;</span>
                                                        <span class="s1">&#39;must have same dtype&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;None of the stages specified in `include` &#39;</span>
                         <span class="s1">&#39;are present in hypno. Returning None.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check data amplitude</span>
    <span class="n">data_trimstd</span> <span class="o">=</span> <span class="n">trimbothstd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
    <span class="n">data_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of samples in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Sampling frequency = </span><span class="si">%.2f</span><span class="s1"> Hz&#39;</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data duration = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Trimmed standard deviation of data = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span><span class="p">,</span> <span class="n">data_trimstd</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Peak-to-peak amplitude of data = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span><span class="p">,</span> <span class="n">data_ptp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">data_trimstd</span> <span class="o">&lt;</span> <span class="mf">1e3</span> <span class="ow">or</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">data_ptp</span> <span class="o">&lt;</span> <span class="mf">1e6</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Wrong data amplitude. Unit must be uV. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check thresholds</span>
    <span class="k">if</span> <span class="s1">&#39;rel_pow&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.20</span>
    <span class="k">if</span> <span class="s1">&#39;corr&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.65</span>
    <span class="k">if</span> <span class="s1">&#39;rms&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">thresh</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>

    <span class="c1"># Define which thresholds to use</span>
    <span class="n">do_rel_pow</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">do_corr</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">do_rms</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="n">n_thresh</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">do_rel_pow</span><span class="p">,</span> <span class="n">do_corr</span><span class="p">,</span> <span class="n">do_rms</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">n_thresh</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;At least one threshold must be defined.&#39;</span>

    <span class="c1"># Check if we can downsample to 100 or 128 Hz</span>
    <span class="k">if</span> <span class="n">downsample</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">sf</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">128</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_sf</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">128</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="n">new_sf</span><span class="p">)</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="n">new_sf</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[::</span><span class="n">fac</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Downsampled data by a factor of </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hypno</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[::</span><span class="n">fac</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot downsample if sf is not a mutiple of 100 &quot;</span>
                           <span class="s2">&quot;or 128. Skipping downsampling.&quot;</span><span class="p">)</span>

    <span class="c1"># Create sleep stage vector mask</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Get data size and next fast length for Hilbert transform</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
    <span class="n">nfast</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Extract the SO signal for coupling</span>
    <span class="k">if</span> <span class="n">coupling</span><span class="p">:</span>
        <span class="n">data_so</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_so</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_so</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span>
                              <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Now extract the instantaneous phase using Hilbert transform</span>
        <span class="n">so_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_so</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:</span><span class="n">n</span><span class="p">])</span>

    <span class="c1"># Bandpass filter</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_broad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_broad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># The width of the transition band is set to 1.5 Hz on each side,</span>
    <span class="c1"># meaning that for freq_sp = (12, 15 Hz), the -6 dB points are located at</span>
    <span class="c1"># 11.25 and 15.75 Hz.</span>
    <span class="n">data_sigma</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                             <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute the pointwise relative power using interpolated STFT</span>
    <span class="c1"># Here we use a step of 200 ms to speed up the computation.</span>
    <span class="c1"># Note that even if the threshold is None we still need to calculate it for</span>
    <span class="c1"># the individual spindles parameter (RelPow).</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">stft_power</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">step</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span> <span class="n">band</span><span class="o">=</span><span class="n">freq_broad</span><span class="p">,</span>
                           <span class="n">interp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">idx_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">f</span> <span class="o">&gt;=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">rel_pow</span> <span class="o">=</span> <span class="n">Sxx</span><span class="p">[</span><span class="n">idx_sigma</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Let&#39;s interpolate `rel_pow` to get one value per sample</span>
    <span class="c1"># Note that we could also have use the `interp=True` in the</span>
    <span class="c1"># `stft_power` function, however 2D interpolation is much slower than</span>
    <span class="c1"># 1D interpolation.</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rel_pow</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">rel_pow</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># Now we apply moving RMS and correlation on the sigma-filtered signal</span>
    <span class="k">if</span> <span class="n">do_corr</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">mcorr</span> <span class="o">=</span> <span class="n">moving_transform</span><span class="p">(</span><span class="n">data_sigma</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_rms</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">mrms</span> <span class="o">=</span> <span class="n">moving_transform</span><span class="p">(</span><span class="n">data_sigma</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">window</span><span class="o">=.</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span>
                                   <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rms&#39;</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Let&#39;s define the thresholds</span>
        <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thresh_rms</span> <span class="o">=</span> <span class="n">mrms</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">*</span> \
                <span class="n">trimbothstd</span><span class="p">(</span><span class="n">mrms</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresh_rms</span> <span class="o">=</span> <span class="n">mrms</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rms&#39;</span><span class="p">]</span> <span class="o">*</span> \
                <span class="n">trimbothstd</span><span class="p">(</span><span class="n">mrms</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
        <span class="c1"># Avoid too high threshold caused by Artefacts / Motion during Wake.</span>
        <span class="n">thresh_rms</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">thresh_rms</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Moving RMS threshold = </span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">thresh_rms</span><span class="p">)</span>

    <span class="c1"># Hilbert power (to define the instantaneous frequency / power)</span>
    <span class="n">analytic</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_sigma</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:</span><span class="n">n</span><span class="p">]</span>
    <span class="n">inst_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic</span><span class="p">)</span>
    <span class="n">inst_pow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">analytic</span><span class="p">))</span>
    <span class="n">inst_freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">inst_phase</span><span class="p">))</span>

    <span class="c1"># Boolean vector of supra-threshold indices</span>
    <span class="n">idx_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_rel_pow</span><span class="p">:</span>
        <span class="n">idx_rel_pow</span> <span class="o">=</span> <span class="p">(</span><span class="n">rel_pow</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;rel_pow&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_rel_pow</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold relative power = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx_rel_pow</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">do_corr</span><span class="p">:</span>
        <span class="n">idx_mcorr</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcorr</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_mcorr</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold moving corr = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx_mcorr</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">do_rms</span><span class="p">:</span>
        <span class="n">idx_mrms</span> <span class="o">=</span> <span class="p">(</span><span class="n">mrms</span> <span class="o">&gt;=</span> <span class="n">thresh_rms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">idx_sum</span> <span class="o">+=</span> <span class="n">idx_mrms</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;N supra-theshold moving RMS = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx_mrms</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="c1"># Make sure that we do not detect spindles in REM or Wake if hypno != None</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idx_sum</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># The detection using the three thresholds tends to underestimate the</span>
    <span class="c1"># real duration of the spindle. To overcome this, we compute a soft</span>
    <span class="c1"># threshold by smoothing the idx_sum vector with a 100 ms window.</span>
    <span class="n">w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">idx_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">idx_sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">w</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
    <span class="c1"># And we then find indices that are strictly greater than 2, i.e. we find</span>
    <span class="c1"># the &#39;true&#39; beginning and &#39;true&#39; end of the events by finding where at</span>
    <span class="c1"># least two out of the three treshold were crossed.</span>
    <span class="n">where_sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx_sum</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">n_thresh</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If no events are found, return an empty dataframe</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">where_sp</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindles were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Merge events that are too close</span>
    <span class="k">if</span> <span class="n">min_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">where_sp</span> <span class="o">=</span> <span class="n">_merge_close</span><span class="p">(</span><span class="n">where_sp</span><span class="p">,</span> <span class="n">min_distance</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>

    <span class="c1"># Extract start, end, and duration of each spindle</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">where_sp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">where_sp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">idx_start_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">])</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">sp_start</span><span class="p">,</span> <span class="n">sp_end</span> <span class="o">=</span> <span class="n">idx_start_end</span><span class="o">.</span><span class="n">T</span>
    <span class="n">sp_dur</span> <span class="o">=</span> <span class="n">sp_end</span> <span class="o">-</span> <span class="n">sp_start</span>

    <span class="c1"># Find events with bad duration</span>
    <span class="n">good_dur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sp_dur</span> <span class="o">&gt;</span> <span class="n">duration</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp_dur</span> <span class="o">&lt;</span> <span class="n">duration</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># If no events of good duration are found, return an empty dataframe</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_dur</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindles were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Initialize empty variables</span>
    <span class="n">n_sp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sp_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_sym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_pro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>
    <span class="n">sp_cou</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sp</span><span class="p">)</span>

    <span class="c1"># Number of oscillations (= number of peaks separated by at least 60 ms)</span>
    <span class="c1"># --&gt; 60 ms because 1000 ms / 16 Hz = 62.5 ms, in other words, at 16 Hz,</span>
    <span class="c1"># peaks are separated by 62.5 ms. At 11 Hz, peaks are separated by 90 ms.</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">sf</span> <span class="o">/</span> <span class="mi">1000</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">))[</span><span class="n">good_dur</span><span class="p">]:</span>
        <span class="c1"># Important: detrend the signal to avoid wrong peak-to-peak amplitude</span>
        <span class="n">sp_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sp_det</span> <span class="o">=</span> <span class="n">_detrend</span><span class="p">(</span><span class="n">sp_x</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="c1"># sp_det = signal.detrend(data[sp[i]], type=&#39;linear&#39;)</span>
        <span class="n">sp_amp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">sp_det</span><span class="p">)</span>  <span class="c1"># Peak-to-peak amplitude</span>
        <span class="n">sp_rms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rms</span><span class="p">(</span><span class="n">sp_det</span><span class="p">)</span>  <span class="c1"># Root mean square</span>
        <span class="n">sp_rel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rel_pow</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>  <span class="c1"># Median relative power</span>

        <span class="c1"># Hilbert-based instantaneous properties</span>
        <span class="n">sp_inst_freq</span> <span class="o">=</span> <span class="n">inst_freq</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">sp_inst_pow</span> <span class="o">=</span> <span class="n">inst_pow</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">sp_abs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sp_inst_pow</span><span class="p">[</span><span class="n">sp_inst_pow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">sp_freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sp_inst_freq</span><span class="p">[</span><span class="n">sp_inst_freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Number of oscillations</span>
        <span class="n">peaks</span><span class="p">,</span> <span class="n">peaks_params</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">sp_det</span><span class="p">,</span>
                                                <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                <span class="n">prominence</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">sp_osc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>

        <span class="c1"># For frequency and amplitude, we can also optionally use these</span>
        <span class="c1"># faster alternatives. If we use them, we do not need to compute the</span>
        <span class="c1"># Hilbert transform of the filtered signal.</span>
        <span class="c1"># sp_freq[i] = sf / np.mean(np.diff(peaks))</span>
        <span class="c1"># sp_amp[i] = peaks_params[&#39;prominences&#39;].max()</span>

        <span class="c1"># Peak location &amp; symmetry index</span>
        <span class="c1"># pk is expressed in sample since the beginning of the spindle</span>
        <span class="n">pk</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">peaks_params</span><span class="p">[</span><span class="s1">&#39;prominences&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span>
        <span class="n">sp_pro</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pk</span> <span class="o">/</span> <span class="n">sf</span>
        <span class="n">sp_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pk</span> <span class="o">/</span> <span class="n">sp_det</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># SO-spindles coupling</span>
        <span class="k">if</span> <span class="n">coupling</span><span class="p">:</span>
            <span class="n">sp_cou</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">so_phase</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">pk</span><span class="p">]</span>

        <span class="c1"># Sleep stage</span>
        <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sp_sta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Create a dictionnary</span>
    <span class="n">sp_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="n">sp_start</span><span class="p">,</span>
                 <span class="s1">&#39;Peak&#39;</span><span class="p">:</span> <span class="n">sp_pro</span><span class="p">,</span>
                 <span class="s1">&#39;End&#39;</span><span class="p">:</span> <span class="n">sp_end</span><span class="p">,</span>
                 <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">sp_dur</span><span class="p">,</span>
                 <span class="s1">&#39;Amplitude&#39;</span><span class="p">:</span> <span class="n">sp_amp</span><span class="p">,</span>
                 <span class="s1">&#39;RMS&#39;</span><span class="p">:</span> <span class="n">sp_rms</span><span class="p">,</span>
                 <span class="s1">&#39;AbsPower&#39;</span><span class="p">:</span> <span class="n">sp_abs</span><span class="p">,</span>
                 <span class="s1">&#39;RelPower&#39;</span><span class="p">:</span> <span class="n">sp_rel</span><span class="p">,</span>
                 <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="n">sp_freq</span><span class="p">,</span>
                 <span class="s1">&#39;Oscillations&#39;</span><span class="p">:</span> <span class="n">sp_osc</span><span class="p">,</span>
                 <span class="s1">&#39;Symmetry&#39;</span><span class="p">:</span> <span class="n">sp_sym</span><span class="p">,</span>
                 <span class="s1">&#39;SOPhase&#39;</span><span class="p">:</span> <span class="n">sp_cou</span><span class="p">,</span>
                 <span class="s1">&#39;Stage&#39;</span><span class="p">:</span> <span class="n">sp_sta</span><span class="p">}</span>

    <span class="n">df_sp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">sp_params</span><span class="p">)[</span><span class="n">good_dur</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df_sp</span> <span class="o">=</span> <span class="n">df_sp</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df_sp</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_sp</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">coupling</span><span class="p">:</span>
        <span class="n">df_sp</span> <span class="o">=</span> <span class="n">df_sp</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;SOPhase&#39;</span><span class="p">])</span>

    <span class="c1"># We need at least 50 detected spindles to apply the Isolation Forest.</span>
    <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df_sp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">IsolationForest</span>
        <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;RMS&#39;</span><span class="p">,</span> <span class="s1">&#39;AbsPower&#39;</span><span class="p">,</span> <span class="s1">&#39;RelPower&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;Oscillations&#39;</span><span class="p">,</span> <span class="s1">&#39;Symmetry&#39;</span><span class="p">]</span>
        <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df_sp</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
        <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed.&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="c1"># Remove outliers from DataFrame</span>
        <span class="n">df_sp</span> <span class="o">=</span> <span class="n">df_sp</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> spindles were found in data.&#39;</span><span class="p">,</span> <span class="n">df_sp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">df_sp</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="spindles_detect_multi"><a class="viewcode-back" href="../../generated/yasa.spindles_detect_multi.html#yasa.spindles_detect_multi">[docs]</a><span class="k">def</span> <span class="nf">spindles_detect_multi</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multi_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multi-channel spindles detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Multi-channel data. Unit must be uV and shape (n_chan, n_samples).</span>
<span class="sd">        Can also be a :py:class:`mne.io.BaseRaw`, in which case ``data``,</span>
<span class="sd">        ``sf``, and ``ch_names`` will be automatically extracted,</span>
<span class="sd">        and ``data`` will also be automatically converted from Volts (MNE)</span>
<span class="sd">        to micro-Volts (YASA).</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data in Hz.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    ch_names : list of str</span>
<span class="sd">        Channel names. Can be omitted if ``data`` is a</span>
<span class="sd">        :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    multi_only : boolean</span>
<span class="sd">        Define the behavior of the multi-channel detection. If True, only</span>
<span class="sd">        spindles that are present on at least two channels are kept. If False,</span>
<span class="sd">        no selection is applied and the output is just a concatenation of the</span>
<span class="sd">        single-channel detection dataframe. Default is False.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keywords arguments that are passed to the</span>
<span class="sd">        :py:func:`yasa.spindles_detect` function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sp_params : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Ouput detection dataframe::</span>

<span class="sd">            &#39;Start&#39; : Start time of each detected spindles (in seconds)</span>
<span class="sd">            &#39;Peak&#39;: Timing of the most prominent spindles peak (in seconds)</span>
<span class="sd">            &#39;End&#39; : End time (in seconds)</span>
<span class="sd">            &#39;Duration&#39; : Duration (in seconds)</span>
<span class="sd">            &#39;Amplitude&#39; : Amplitude (in uV)</span>
<span class="sd">            &#39;RMS&#39; : Root-mean-square (in uV)</span>
<span class="sd">            &#39;AbsPower&#39; : Median absolute power (in log10 uV^2)</span>
<span class="sd">            &#39;RelPower&#39; : Median relative power (ranging from 0 to 1, in % uV^2)</span>
<span class="sd">            &#39;Frequency&#39; : Median frequency (in Hz)</span>
<span class="sd">            &#39;Oscillations&#39; : Number of oscillations (peaks)</span>
<span class="sd">            &#39;Symmetry&#39; : Symmetry index, ranging from 0 to 1</span>
<span class="sd">            &#39;SOPhase&#39;: SO phase (radians) at the most prominent spindle peak</span>
<span class="sd">            &#39;Stage&#39; : Sleep stage (only if hypno was provided)</span>
<span class="sd">            &#39;Channel&#39; : Channel name</span>
<span class="sd">            &#39;IdxChannel&#39; : Integer index of channel in data</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For an example of how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/02_spindles_detection_multi.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if input data is a MNE Raw object</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>  <span class="c1"># Extract sampling frequency</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ch_names</span>  <span class="c1"># Extract channel names</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span>  <span class="c1"># Convert from V to uV</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">sf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sf must be specified if not using MNE Raw.&#39;</span>
        <span class="k">assert</span> <span class="n">ch_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;ch_names must be specified if not &#39;</span>
                                      <span class="s1">&#39;using MNE Raw.&#39;</span><span class="p">)</span>

    <span class="c1"># Safety check</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_chan</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_chan</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;ch_names must have same length as data.shape[0]&#39;</span><span class="p">)</span>

    <span class="c1"># Single channel detection</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">):</span>
        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">spindles_detect</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df_chan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindles were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span>
                           <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># If no spindles were detected, return None</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No spindles were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Find spindles that are present on at least two channels</span>
    <span class="k">if</span> <span class="n">multi_only</span> <span class="ow">and</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># We round to the nearest second</span>
        <span class="n">idx_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                 <span class="n">df</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                 <span class="p">)</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">idx_good</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># SLOW-WAVES DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="sw_detect"><a class="viewcode-back" href="../../generated/yasa.sw_detect.html#yasa.sw_detect">[docs]</a><span class="k">def</span> <span class="nf">sw_detect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">freq_sw</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
              <span class="n">dur_neg</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">dur_pos</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">amp_neg</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span>
              <span class="n">amp_pos</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">amp_ptp</span><span class="o">=</span><span class="p">(</span><span class="mi">75</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="n">downsample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">coupling</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">freq_sp</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Slow-waves detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Single-channel continuous EEG data. Unit must be uV.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The default unit of :py:class:`mne.io.BaseRaw` is Volts.</span>
<span class="sd">            Therefore, if passing data from a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">            you need to multiply the data by 1e6 to convert to micro-Volts</span>
<span class="sd">            (1 V = 1,000,000 uV), e.g.:</span>

<span class="sd">            .. code-block:: ruby</span>

<span class="sd">                data = raw.get_data() * 1e6  # Make sure that data is in uV</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data, in Hz.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage vector (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = N2 + N3 sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM sleep</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (2, 3), meaning that the detection is applied on N2 and N3</span>
<span class="sd">        sleep. This has no effect when ``hypno`` is None.</span>
<span class="sd">    freq_sw : tuple or list</span>
<span class="sd">        Slow wave frequency range. Default is 0.3 to 2 Hz. Please note that</span>
<span class="sd">        YASA uses a FIR filter (implemented in MNE) with a 0.2 Hz transition</span>
<span class="sd">        band, which means that the -6 dB points are located at 0.2 and 2.1 Hz.</span>
<span class="sd">    dur_neg : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the negative deflection of the</span>
<span class="sd">        slow wave. Default is 0.3 to 1.5 second.</span>
<span class="sd">    dur_pos : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the positive deflection of the</span>
<span class="sd">        slow wave. Default is 0.1 to 1 second.</span>
<span class="sd">    amp_neg : tuple or list</span>
<span class="sd">        Absolute minimum and maximum negative trough amplitude of the</span>
<span class="sd">        slow-wave. Default is 40 uV to 300 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored. If you do not want</span>
<span class="sd">        to specify any negative amplitude thresholds,</span>
<span class="sd">        use ``amp_neg=(None, None)``.</span>
<span class="sd">    amp_pos : tuple or list</span>
<span class="sd">        Absolute minimum and maximum positive peak amplitude of the</span>
<span class="sd">        slow-wave. Default is 10 uV to 200 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored.</span>
<span class="sd">        If you do not want to specify any positive amplitude thresholds,</span>
<span class="sd">        use ``amp_pos=(None, None)``.</span>
<span class="sd">    amp_ptp : tuple or list</span>
<span class="sd">        Minimum and maximum peak-to-peak amplitude of the slow-wave.</span>
<span class="sd">        Default is 75 uV to 500 uV. Can also be in unit of standard</span>
<span class="sd">        deviations if the data has been previously z-scored.</span>
<span class="sd">        Use ``np.inf`` to set no upper amplitude threshold</span>
<span class="sd">        (e.g. ``amp_ptp=(75, np.inf)``).</span>
<span class="sd">    downsample : boolean</span>
<span class="sd">        If True, the data will be downsampled to 100 Hz or 128 Hz (depending</span>
<span class="sd">        on whether the original sampling frequency is a multiple of 100 or 128,</span>
<span class="sd">        respectively).</span>
<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers slow-waves</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        The outliers detection is performed on the frequency, amplitude and</span>
<span class="sd">        duration parameters of the detected slow-waves. YASA uses a random seed</span>
<span class="sd">        (42) to ensure reproducible results. Note that this step will only be</span>
<span class="sd">        applied if there are more than 50 detected slow-waves in the first</span>
<span class="sd">        place. Default to False.</span>
<span class="sd">    coupling : boolean</span>
<span class="sd">        If True, YASA will also calculate the phase-amplitude coupling between</span>
<span class="sd">        the slow-waves phase and the spindles-related sigma band</span>
<span class="sd">        amplitude. Specifically, the output will be the</span>
<span class="sd">        phase of the bandpas-filtered slow-wave signal (in radians) at the</span>
<span class="sd">        maximum sigma peak amplitude within an 4-seconds epoch centered around</span>
<span class="sd">        the negative peak (through) of the current slow-wave.</span>
<span class="sd">        The lower and upper frequencies for the slow-waves and</span>
<span class="sd">        spindles-related sigma signals are defined in ``freq_sw`` and</span>
<span class="sd">        ``freq_sp``, respectively.</span>

<span class="sd">        Importantly, since the resulting variable is expressed in radians,</span>
<span class="sd">        one should use circular statistics to calculate the mean direction</span>
<span class="sd">        and vector length:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            import pingouin as pg</span>
<span class="sd">            mean_direction = pg.circ_mean(sw[&#39;PhaseAtSigmaPeak&#39;])</span>
<span class="sd">            vector_length = pg.circ_r(sw[&#39;PhaseAtSigmaPeak&#39;])</span>

<span class="sd">        For more details, please refer to the `Jupyter notebook</span>
<span class="sd">        &lt;https://github.com/raphaelvallat/yasa/blob/master/notebooks/12_spindles-SO_coupling.ipynb&gt;`_</span>

<span class="sd">        Note that setting ``coupling=True`` may significantly increase</span>
<span class="sd">        computation time.</span>

<span class="sd">        .. versionadded:: 0.2.0</span>

<span class="sd">    freq_sp : tuple or list</span>
<span class="sd">        Spindles-related frequency of interest. This is only relevant if</span>
<span class="sd">        ``coupling=True``. Default is 12 to 16 Hz, with a wide transition</span>
<span class="sd">        bandwidth of 1.5 Hz.</span>

<span class="sd">        .. versionadded:: 0.2.0</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sw_params : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Ouput detection dataframe::</span>

<span class="sd">            &#39;Start&#39; : Start of each detected slow-wave (in seconds of data)</span>
<span class="sd">            &#39;NegPeak&#39; : Location of the negative peak (in seconds of data)</span>
<span class="sd">            &#39;MidCrossing&#39; : Location of the negative-to-positive zero-crossing</span>
<span class="sd">            &#39;Pospeak&#39; : Location of the positive peak</span>
<span class="sd">            &#39;End&#39; : End time (in seconds)</span>
<span class="sd">            &#39;Duration&#39; : Duration (in seconds)</span>
<span class="sd">            &#39;ValNegPeak&#39; : Amplitude of the negative peak (in uV - filtered)</span>
<span class="sd">            &#39;ValPosPeak&#39; : Amplitude of the positive peak (in uV - filtered)</span>
<span class="sd">            &#39;PTP&#39; : Peak to peak amplitude (ValPosPeak - ValNegPeak)</span>
<span class="sd">            &#39;Slope&#39; : Slope between ``NegPeak`` and ``MidCrossing`` (in uV/sec)</span>
<span class="sd">            &#39;Frequency&#39; : Frequency of the slow-wave (1 / ``Duration``)</span>
<span class="sd">            &#39;PhaseAtSigmaPeak&#39;: SW phase at max sigma amplitude in 4-sec epoch</span>
<span class="sd">            &#39;Stage&#39; : Sleep stage (only if hypno was provided)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For better results, apply this detection only on artefact-free NREM sleep.</span>

<span class="sd">    Note that the ``PTP``, ``Slope``, ``ValNegPeak`` and ``ValPosPeak`` are</span>
<span class="sd">    all computed on the filtered signal.</span>

<span class="sd">    For an example of how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/05_sw_detection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Safety check</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Wrong data dimension. Please pass 1D data.&#39;</span>
    <span class="n">freq_sw</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">freq_sw</span><span class="p">)</span>
    <span class="n">amp_ptp</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">amp_ptp</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">downsample</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;Downsample must be True or False.&#39;</span>

    <span class="c1"># Hypno processing</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Hypno must be one dimensional.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Hypno must have same size as data.&#39;</span>
        <span class="n">unique_hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of unique values in hypno = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">unique_hypno</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># Check include</span>
        <span class="k">assert</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;include cannot be None if hypno is given&#39;</span>
        <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">include</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">include</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;`include` must have at least one element.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">include</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hypno and include &#39;</span>
                                                        <span class="s1">&#39;must have same dtype&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;None of the stages specified in `include` &#39;</span>
                         <span class="s1">&#39;are present in hypno. Returning None.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check data amplitude</span>
    <span class="n">data_trimstd</span> <span class="o">=</span> <span class="n">trimbothstd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
    <span class="n">data_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of samples in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Sampling frequency = </span><span class="si">%.2f</span><span class="s1"> Hz&#39;</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data duration = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Trimmed standard deviation of data = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span><span class="p">,</span> <span class="n">data_trimstd</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Peak-to-peak amplitude of data = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span><span class="p">,</span> <span class="n">data_ptp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">data_trimstd</span> <span class="o">&lt;</span> <span class="mf">1e3</span> <span class="ow">or</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">data_ptp</span> <span class="o">&lt;</span> <span class="mf">1e6</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Wrong data amplitude. Unit must be uV. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check if we can downsample to 100 or 128 Hz</span>
    <span class="k">if</span> <span class="n">downsample</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">sf</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">128</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_sf</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">128</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="n">new_sf</span><span class="p">)</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="n">new_sf</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[::</span><span class="n">fac</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Downsampled data by a factor of </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hypno</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[::</span><span class="n">fac</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot downsample if sf is not a mutiple of 100 &quot;</span>
                           <span class="s2">&quot;or 128. Skipping downsampling.&quot;</span><span class="p">)</span>

    <span class="c1"># Define time vector</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>

    <span class="c1"># Get data size and next fast length for Hilbert transform</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span>
    <span class="n">nfast</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Bandpass filter</span>
    <span class="n">data_filt</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                            <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

    <span class="c1"># Extract the spindles-related sigma signal for coupling</span>
    <span class="k">if</span> <span class="n">coupling</span><span class="p">:</span>
        <span class="c1"># The width of the transition band is set to 1.5 Hz on each side,</span>
        <span class="c1"># meaning that for freq_sp = (12, 15 Hz), the -6 dB points are located</span>
        <span class="c1"># at 11.25 and 15.75 Hz. The frequency band for the amplitude signal</span>
        <span class="c1"># must be large enough to fit the sidebands caused by the assumed</span>
        <span class="c1"># modulating lower frequency band (Aru et al. 2015).</span>
        <span class="c1"># https://doi.org/10.1016/j.conb.2014.08.002</span>
        <span class="n">data_sp</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span>
                              <span class="n">l_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">h_trans_bandwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Now extract the instantaneous phase/amplitude using Hilbert transform</span>
        <span class="n">sw_pha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_filt</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:</span><span class="n">n</span><span class="p">])</span>
        <span class="n">sp_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">data_sp</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">nfast</span><span class="p">)[:</span><span class="n">n</span><span class="p">])</span>

    <span class="c1"># Find peaks in data</span>
    <span class="c1"># Negative peaks with value comprised between -40 to -300 uV</span>
    <span class="n">idx_neg_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">data_filt</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">amp_neg</span><span class="p">)</span>

    <span class="c1"># Positive peaks with values comprised between 10 to 150 uV</span>
    <span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">data_filt</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">amp_pos</span><span class="p">)</span>

    <span class="c1"># Intersect with sleep stage vector</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>
        <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx_neg_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">idx_neg_peaks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span>
                                       <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span>
                                       <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># If no peaks are detected, return None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_neg_peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No peaks were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Make sure that the last detected peak is a positive one</span>
    <span class="k">if</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># If not, append a fake positive peak one sample after the last neg</span>
        <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># For each negative peak, we find the closest following positive peak</span>
    <span class="n">pk_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">)</span>
    <span class="n">closest_pos_peaks</span> <span class="o">=</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="n">pk_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>
    <span class="n">closest_pos_peaks</span> <span class="o">=</span> <span class="n">closest_pos_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">closest_pos_peaks</span><span class="p">)]</span>
    <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">closest_pos_peaks</span>

    <span class="c1"># Now we compute the PTP amplitude and keep only the good peaks</span>
    <span class="n">sw_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_filt</span><span class="p">[</span><span class="n">idx_neg_peaks</span><span class="p">])</span> <span class="o">+</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">idx_pos_peaks</span><span class="p">]</span>
    <span class="n">good_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sw_ptp</span> <span class="o">&gt;</span> <span class="n">amp_ptp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sw_ptp</span> <span class="o">&lt;</span> <span class="n">amp_ptp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># If good_ptp is all False</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_ptp</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No slow-wave with good amplitude. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">sw_ptp</span> <span class="o">=</span> <span class="n">sw_ptp</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>
    <span class="n">idx_neg_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>
    <span class="n">idx_pos_peaks</span> <span class="o">=</span> <span class="n">idx_pos_peaks</span><span class="p">[</span><span class="n">good_ptp</span><span class="p">]</span>

    <span class="c1"># Now we need to check the negative and positive phase duration</span>
    <span class="c1"># For that we need to compute the zero crossings of the filtered signal</span>
    <span class="n">zero_crossings</span> <span class="o">=</span> <span class="n">_zerocrossings</span><span class="p">(</span><span class="n">data_filt</span><span class="p">)</span>
    <span class="c1"># Make sure that there is a zero-crossing after the last detected peak</span>
    <span class="k">if</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># If not, append the index of the last peak</span>
        <span class="n">zero_crossings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span>
                                   <span class="nb">max</span><span class="p">(</span><span class="n">idx_pos_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">idx_neg_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Find distance to previous and following zc</span>
    <span class="n">neg_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span> <span class="n">idx_neg_peaks</span><span class="p">)</span>
    <span class="n">previous_neg_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">neg_sorted</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>
    <span class="n">following_neg_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">neg_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_neg_peaks</span>
    <span class="n">neg_phase_dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">previous_neg_zc</span><span class="p">)</span> <span class="o">+</span> <span class="n">following_neg_zc</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>

    <span class="c1"># Distance (in samples) between the positive peaks and the previous and</span>
    <span class="c1"># following zero-crossings</span>
    <span class="n">pos_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">zero_crossings</span><span class="p">,</span> <span class="n">idx_pos_peaks</span><span class="p">)</span>
    <span class="n">previous_pos_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">pos_sorted</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_pos_peaks</span>
    <span class="n">following_pos_zc</span> <span class="o">=</span> <span class="n">zero_crossings</span><span class="p">[</span><span class="n">pos_sorted</span><span class="p">]</span> <span class="o">-</span> <span class="n">idx_pos_peaks</span>
    <span class="n">pos_phase_dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">previous_pos_zc</span><span class="p">)</span> <span class="o">+</span> <span class="n">following_pos_zc</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>

    <span class="c1"># We now compute a set of metrics</span>
    <span class="n">sw_start</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">previous_neg_zc</span><span class="p">]</span>  <span class="c1"># Start in time vector</span>
    <span class="n">sw_end</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_pos_peaks</span> <span class="o">+</span> <span class="n">following_pos_zc</span><span class="p">]</span>  <span class="c1"># End in time vector</span>
    <span class="n">sw_dur</span> <span class="o">=</span> <span class="n">sw_end</span> <span class="o">-</span> <span class="n">sw_start</span>  <span class="c1"># Same as pos_phase_dur + neg_phase_dur</span>
    <span class="n">sw_midcrossing</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span> <span class="o">+</span> <span class="n">following_neg_zc</span><span class="p">]</span>  <span class="c1"># Neg-to-pos zc</span>
    <span class="n">sw_idx_neg</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_neg_peaks</span><span class="p">]</span>  <span class="c1"># Location of negative peak</span>
    <span class="n">sw_idx_pos</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_pos_peaks</span><span class="p">]</span>  <span class="c1"># Location of positive peak</span>
    <span class="c1"># Slope between peak trough and midcrossing</span>
    <span class="n">sw_slope</span> <span class="o">=</span> <span class="n">sw_ptp</span> <span class="o">/</span> <span class="p">(</span><span class="n">sw_midcrossing</span> <span class="o">-</span> <span class="n">sw_idx_neg</span><span class="p">)</span>
    <span class="c1"># Hypnogram</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sw_sta</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">idx_neg_peaks</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sw_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sw_dur</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># And we apply a set of thresholds to remove bad slow waves</span>
    <span class="n">good_sw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span>
                                    <span class="c1"># Data edges</span>
                                    <span class="n">previous_neg_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                    <span class="n">following_neg_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                    <span class="n">previous_pos_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                    <span class="n">following_pos_zc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                    <span class="c1"># Duration criteria</span>
                                    <span class="n">neg_phase_dur</span> <span class="o">&gt;</span> <span class="n">dur_neg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">neg_phase_dur</span> <span class="o">&lt;</span> <span class="n">dur_neg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">pos_phase_dur</span> <span class="o">&gt;</span> <span class="n">dur_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">pos_phase_dur</span> <span class="o">&lt;</span> <span class="n">dur_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="c1"># Sanity checks</span>
                                    <span class="n">sw_midcrossing</span> <span class="o">&gt;</span> <span class="n">sw_start</span><span class="p">,</span>
                                    <span class="n">sw_midcrossing</span> <span class="o">&lt;</span> <span class="n">sw_end</span><span class="p">,</span>
                                    <span class="n">sw_slope</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
                                    <span class="p">))</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="o">~</span><span class="n">good_sw</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No slow-wave satisfying all criteria. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Create a dictionnary and then a dataframe (much faster)</span>
    <span class="n">sw_params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({</span><span class="s1">&#39;Start&#39;</span><span class="p">:</span> <span class="n">sw_start</span><span class="p">,</span>
                             <span class="s1">&#39;NegPeak&#39;</span><span class="p">:</span> <span class="n">sw_idx_neg</span><span class="p">,</span>
                             <span class="s1">&#39;MidCrossing&#39;</span><span class="p">:</span> <span class="n">sw_midcrossing</span><span class="p">,</span>
                             <span class="s1">&#39;PosPeak&#39;</span><span class="p">:</span> <span class="n">sw_idx_pos</span><span class="p">,</span>
                             <span class="s1">&#39;End&#39;</span><span class="p">:</span> <span class="n">sw_end</span><span class="p">,</span>
                             <span class="s1">&#39;Duration&#39;</span><span class="p">:</span> <span class="n">sw_dur</span><span class="p">,</span>
                             <span class="s1">&#39;ValNegPeak&#39;</span><span class="p">:</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">idx_neg_peaks</span><span class="p">],</span>
                             <span class="s1">&#39;ValPosPeak&#39;</span><span class="p">:</span> <span class="n">data_filt</span><span class="p">[</span><span class="n">idx_pos_peaks</span><span class="p">],</span>
                             <span class="s1">&#39;PTP&#39;</span><span class="p">:</span> <span class="n">sw_ptp</span><span class="p">,</span>
                             <span class="s1">&#39;Slope&#39;</span><span class="p">:</span> <span class="n">sw_slope</span><span class="p">,</span>
                             <span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sw_dur</span><span class="p">,</span>
                             <span class="s1">&#39;Stage&#39;</span><span class="p">:</span> <span class="n">sw_sta</span><span class="p">,</span>
                             <span class="p">})</span>

    <span class="c1"># Add phase (in radians) of slow-oscillation signal at maximum</span>
    <span class="c1"># spindles-related sigma amplitude within a 4-seconds centered epochs.</span>
    <span class="k">if</span> <span class="n">coupling</span><span class="p">:</span>
        <span class="c1"># The following lines are borrowed from yasa.get_sync_events</span>
        <span class="n">time_before</span> <span class="o">=</span> <span class="n">time_after</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">N_bef</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_before</span><span class="p">)</span>
        <span class="n">N_aft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">*</span> <span class="n">time_after</span><span class="p">)</span>
        <span class="c1"># Convert to integer sample indices in data</span>
        <span class="n">n_peaks</span> <span class="o">=</span> <span class="n">idx_neg_peaks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx_peak</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_neg_peaks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">rng</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Utility function to create a range before and after</span>
<span class="sd">            a given value.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">N_bef</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">N_aft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx_peak</span><span class="p">)</span>
        <span class="c1"># We drop the events for which the indices exceed data</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_rows</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_outside</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">idx_nomask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">compress_rows</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="c1"># sw_pha is a 2-D array of shape (n_events, N_bef + N_aft + 1)</span>
        <span class="n">sw_pha_ev</span> <span class="o">=</span> <span class="n">sw_pha</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">sp_amp_ev</span> <span class="o">=</span> <span class="n">sp_amp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># Find SW phase at max sigma amplitude in epoch</span>
        <span class="n">pha_at_max</span> <span class="o">=</span> <span class="n">sw_pha_ev</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sp_amp_ev</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Now we need to append it back to the original unmasked shape</span>
        <span class="n">pha_at_max_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_peaks</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">pha_at_max_full</span><span class="p">[</span><span class="n">idx_nomask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pha_at_max</span>
        <span class="n">sw_params</span><span class="p">[</span><span class="s1">&#39;PhaseAtSigmaPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pha_at_max_full</span>
        <span class="c1"># Make sure that Stage is the last column of the dataframe</span>
        <span class="n">sw_params</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="s1">&#39;Stage&#39;</span><span class="p">)</span>

    <span class="c1"># Convert to dataframe, keeping only good events</span>
    <span class="n">df_sw</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">sw_params</span><span class="p">)[</span><span class="n">good_sw</span><span class="p">]</span>

    <span class="c1"># Remove all duplicates</span>
    <span class="n">df_sw</span> <span class="o">=</span> <span class="n">df_sw</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">df_sw</span> <span class="o">=</span> <span class="n">df_sw</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df_sw</span> <span class="o">=</span> <span class="n">df_sw</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df_sw</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_sw</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

    <span class="c1"># We need at least 50 detected slow waves to apply the Isolation Forest.</span>
    <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df_sw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">IsolationForest</span>
        <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;ValNegPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;ValPosPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;PTP&#39;</span><span class="p">,</span> <span class="s1">&#39;Slope&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;Frequency&#39;</span><span class="p">]</span>
        <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df_sw</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
        <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed.&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="c1"># Remove outliers from DataFrame</span>
        <span class="n">df_sw</span> <span class="o">=</span> <span class="n">df_sw</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> slow-waves were found in data.&#39;</span><span class="p">,</span> <span class="n">df_sw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">df_sw</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="sw_detect_multi"><a class="viewcode-back" href="../../generated/yasa.sw_detect_multi.html#yasa.sw_detect_multi">[docs]</a><span class="k">def</span> <span class="nf">sw_detect_multi</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multi-channel slow-waves detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Multi-channel data. Unit must be uV and shape (n_chan, n_samples).</span>
<span class="sd">        Can also be a :py:class:`mne.io.BaseRaw`, in which case ``data``,</span>
<span class="sd">        ``sf``, and ``ch_names`` will be automatically extracted,</span>
<span class="sd">        and ``data`` will also be automatically converted from Volts (MNE)</span>
<span class="sd">        to micro-Volts (YASA).</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data in Hz.</span>
<span class="sd">        Can be omitted if ``data`` is a :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    ch_names : list of str</span>
<span class="sd">        Channel names. Can be omitted if ``data`` is a</span>
<span class="sd">        :py:class:`mne.io.BaseRaw`.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keywords arguments that are passed to the :py:func:`yasa.sw_detect`</span>
<span class="sd">        function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sw_params : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Ouput detection dataframe::</span>

<span class="sd">            &#39;Start&#39; : Start of each detected slow-wave (in seconds of data)</span>
<span class="sd">            &#39;NegPeak&#39; : Location of the negative peak (in seconds of data)</span>
<span class="sd">            &#39;MidCrossing&#39; : Location of the negative-to-positive zero-crossing</span>
<span class="sd">            &#39;Pospeak&#39; : Location of the positive peak</span>
<span class="sd">            &#39;End&#39; : End time (in seconds)</span>
<span class="sd">            &#39;Duration&#39; : Duration (in seconds)</span>
<span class="sd">            &#39;ValNegPeak&#39; : Amplitude of the negative peak (in uV - filtered)</span>
<span class="sd">            &#39;ValPosPeak&#39; : Amplitude of the positive peak (in uV - filtered)</span>
<span class="sd">            &#39;PTP&#39; : Peak to peak amplitude (ValPosPeak - ValNegPeak)</span>
<span class="sd">            &#39;Slope&#39; : Slope between ``NegPeak`` and ``MidCrossing`` (in uV/sec)</span>
<span class="sd">            &#39;Frequency&#39; : Frequency of the slow-wave (1 / ``Duration``)</span>
<span class="sd">            &#39;PhaseAtSigmaPeak&#39;: SW phase at max sigma amplitude in 4-sec epoch</span>
<span class="sd">            &#39;Stage&#39; : Sleep stage (only if hypno was provided)</span>
<span class="sd">            &#39;Channel&#39; : Channel name</span>
<span class="sd">            &#39;IdxChannel&#39; : Integer index of channel in data</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For better results, apply this detection only on artefact-free NREM sleep.</span>

<span class="sd">    Note that the ``PTP``, ``Slope``, ``ValNegPeak`` and ``ValPosPeak`` are</span>
<span class="sd">    computed on the filtered signal.</span>

<span class="sd">    For an example of how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/06_sw_detection_multi.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if input data is a MNE Raw object</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mne</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">BaseRaw</span><span class="p">):</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>  <span class="c1"># Extract sampling frequency</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ch_names</span>  <span class="c1"># Extract channel names</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span>  <span class="c1"># Convert from V to uV</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">sf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;sf must be specified if not using MNE Raw.&#39;</span>
        <span class="k">assert</span> <span class="n">ch_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;ch_names must be specified if not &#39;</span>
                                      <span class="s1">&#39;using MNE Raw.&#39;</span><span class="p">)</span>

    <span class="c1"># Safety check</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_chan</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_names</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_chan</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;ch_names must have same length as data.shape[0]&#39;</span><span class="p">)</span>

    <span class="c1"># Single channel detection</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chan</span><span class="p">):</span>
        <span class="n">df_chan</span> <span class="o">=</span> <span class="n">sw_detect</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df_chan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;Channel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">df_chan</span><span class="p">[</span><span class="s1">&#39;IdxChannel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_chan</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No slow-waves were found in channel </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span>
                           <span class="n">ch_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># If no slow-waves were detected, return None</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No slow-waves were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1">#############################################################################</span>
<span class="c1"># REMs DETECTION</span>
<span class="c1">#############################################################################</span>


<div class="viewcode-block" id="rem_detect"><a class="viewcode-back" href="../../generated/yasa.rem_detect.html#yasa.rem_detect">[docs]</a><span class="k">def</span> <span class="nf">rem_detect</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">roc</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">hypno</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">325</span><span class="p">),</span>
               <span class="n">duration</span><span class="o">=</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">),</span> <span class="n">freq_rem</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">downsample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">remove_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rapid Eye Movements (REMs) detection.</span>

<span class="sd">    This detection requires both the left EOG (LOC) and right EOG (LOC).</span>
<span class="sd">    The units of the data must be uV. The algorithm is based on an amplitude</span>
<span class="sd">    thresholding of the negative product of the LOC and ROC</span>
<span class="sd">    filtered signal.</span>

<span class="sd">    .. versionadded:: 0.1.5</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loc, roc : array_like</span>
<span class="sd">        Continuous EOG data (Left and Right Ocular Canthi, LOC / ROC) channels.</span>
<span class="sd">        Unit must be uV.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The default unit of :py:class:`mne.io.BaseRaw` is Volts.</span>
<span class="sd">            Therefore, if passing data from a :py:class:`mne.io.BaseRaw`,</span>
<span class="sd">            you need to multiply the data by 1e6 to convert to micro-Volts</span>
<span class="sd">            (1 V = 1,000,000 uV), e.g.:</span>

<span class="sd">            .. code-block:: ruby</span>

<span class="sd">                data = raw.get_data() * 1e6  # Make sure that data is in uV</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency of the data, in Hz.</span>
<span class="sd">    hypno : array_like</span>
<span class="sd">        Sleep stage vector (hypnogram). If the hypnogram is loaded, the</span>
<span class="sd">        detection will only be applied to the value defined in</span>
<span class="sd">        ``include`` (default = REM sleep).</span>

<span class="sd">        The hypnogram must have the same number of samples as ``data``.</span>
<span class="sd">        To upsample your hypnogram, please refer to</span>
<span class="sd">        :py:func:`yasa.hypno_upsample_to_data`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default hypnogram format in YASA is a 1D integer</span>
<span class="sd">            vector where:</span>

<span class="sd">            - -1 = Artefact / Movement</span>
<span class="sd">            - 0 = Wake</span>
<span class="sd">            - 1 = N1 sleep</span>
<span class="sd">            - 2 = N2 sleep</span>
<span class="sd">            - 3 = N3 sleep</span>
<span class="sd">            - 4 = REM</span>
<span class="sd">    include : tuple, list or int</span>
<span class="sd">        Values in ``hypno`` that will be included in the mask. The default is</span>
<span class="sd">        (4), meaning that the detection is applied on REM sleep.</span>
<span class="sd">        This has no effect when ``hypno`` is None.</span>
<span class="sd">    amplitude : tuple or list</span>
<span class="sd">        Minimum and maximum amplitude of the peak of the REM.</span>
<span class="sd">        Default is 50 uV to 325 uV.</span>
<span class="sd">    duration : tuple or list</span>
<span class="sd">        The minimum and maximum duration of the REMs.</span>
<span class="sd">        Default is 0.3 to 1.2 seconds.</span>
<span class="sd">    freq_rem : tuple or list</span>
<span class="sd">        Frequency range of REMs. Default is 0.5 to 5 Hz.</span>
<span class="sd">    downsample : boolean</span>
<span class="sd">        If True, the data will be downsampled to 100 Hz or 128 Hz (depending</span>
<span class="sd">        on whether the original sampling frequency is a multiple of 100 or 128,</span>
<span class="sd">        respectively).</span>
<span class="sd">    remove_outliers : boolean</span>
<span class="sd">        If True, YASA will automatically detect and remove outliers REMs</span>
<span class="sd">        using :py:class:`sklearn.ensemble.IsolationForest`.</span>
<span class="sd">        YASA uses a random seed (42) to ensure reproducible results.</span>
<span class="sd">        Note that this step will only be applied if there are more than</span>
<span class="sd">        50 detected REMs in the first place. Default to False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_rem : :py:class:`pandas.DataFrame`</span>
<span class="sd">        Ouput detection dataframe::</span>

<span class="sd">            &#39;Start&#39; : Start of each detected REM (in seconds of data)</span>
<span class="sd">            &#39;Peak&#39; : Location of the peak (in seconds of data)</span>
<span class="sd">            &#39;End&#39; : End time (in seconds)</span>
<span class="sd">            &#39;Duration&#39; : Duration (in seconds)</span>
<span class="sd">            &#39;LOCAbsValPeak&#39; : LOC absolute amplitude at REM peak (in uV)</span>
<span class="sd">            &#39;ROCAbsValPeak&#39; : ROC absolute amplitude at REM peak (in uV)</span>
<span class="sd">            &#39;LOCAbsRiseSlope&#39; : LOC absolute rise slope (in uV/s)</span>
<span class="sd">            &#39;ROCAbsRiseSlope&#39; : ROC absolute rise slope (in uV/s)</span>
<span class="sd">            &#39;LOCAbsFallSlope&#39; : LOC absolute fall slope (in uV/s)</span>
<span class="sd">            &#39;ROCAbsFallSlope&#39; : ROC absolute fall slope (in uV/s)</span>
<span class="sd">            &#39;Stage&#39; : Sleep stage (only if hypno was provided)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For better results, apply this detection only on artefact-free REM sleep.</span>

<span class="sd">    Note that all the output parameters are computed on the filtered LOC and</span>
<span class="sd">    ROC signals.</span>

<span class="sd">    For an example of how to run the detection, please refer to</span>
<span class="sd">    https://github.com/raphaelvallat/yasa/blob/master/notebooks/07_REMs_detection.ipynb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Safety checks</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
    <span class="n">roc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">roc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">loc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;LOC must be 1D.&#39;</span>
    <span class="k">assert</span> <span class="n">roc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;ROC must be 1D.&#39;</span>
    <span class="k">assert</span> <span class="n">loc</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">roc</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;LOC and ROC must have the same size.&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">downsample</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;Downsample must be True or False.&#39;</span>
    <span class="n">freq_rem</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">freq_rem</span><span class="p">)</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
    <span class="n">amplitude</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">amplitude</span><span class="p">)</span>

    <span class="c1"># Hypno processing</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Hypno must be one dimensional.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">loc</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Hypno must have same size as data.&#39;</span>
        <span class="n">unique_hypno</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">hypno</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of unique values in hypno = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">unique_hypno</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># Check include</span>
        <span class="k">assert</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;include cannot be None if hypno is given&#39;</span>
        <span class="n">include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">include</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">include</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;`include` must have at least one element.&#39;</span>
        <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">include</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;hypno and include &#39;</span>
                                                        <span class="s1">&#39;must have same dtype&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;None of the stages specified in `include` &#39;</span>
                         <span class="s1">&#39;are present in hypno. Returning None.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check data amplitude</span>
    <span class="c1"># times = np.arange(data.size) / sf</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="n">roc</span><span class="p">))</span>
    <span class="n">loc_trimstd</span> <span class="o">=</span> <span class="n">trimbothstd</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
    <span class="n">roc_trimstd</span> <span class="o">=</span> <span class="n">trimbothstd</span><span class="p">(</span><span class="n">roc</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mf">0.10</span><span class="p">)</span>
    <span class="n">loc_ptp</span><span class="p">,</span> <span class="n">roc_ptp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">loc</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">roc</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of samples in data = </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Original sampling frequency = </span><span class="si">%.2f</span><span class="s1"> Hz&#39;</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data duration = </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Trimmed standard deviation of LOC = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span><span class="p">,</span> <span class="n">loc_trimstd</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Trimmed standard deviation of ROC = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span><span class="p">,</span> <span class="n">roc_trimstd</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Peak-to-peak amplitude of LOC = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span><span class="p">,</span> <span class="n">loc_ptp</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Peak-to-peak amplitude of ROC = </span><span class="si">%.4f</span><span class="s1"> uV&#39;</span><span class="p">,</span> <span class="n">roc_ptp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">loc_trimstd</span> <span class="o">&lt;</span> <span class="mf">1e3</span> <span class="ow">or</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">loc_ptp</span> <span class="o">&lt;</span> <span class="mf">1e6</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Wrong LOC amplitude. Unit must be uV. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">roc_trimstd</span> <span class="o">&lt;</span> <span class="mf">1e3</span> <span class="ow">or</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">roc_ptp</span> <span class="o">&lt;</span> <span class="mf">1e6</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Wrong ROC amplitude. Unit must be uV. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check if we can downsample to 100 or 128 Hz</span>
    <span class="k">if</span> <span class="n">downsample</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">sf</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">128</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_sf</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="n">sf</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">128</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="n">new_sf</span><span class="p">)</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="n">new_sf</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">::</span><span class="n">fac</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Downsampled data by a factor of </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fac</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hypno</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[::</span><span class="n">fac</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">hypno</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot downsample if sf is not a mutiple of 100 &quot;</span>
                           <span class="s2">&quot;or 128. Skipping downsampling.&quot;</span><span class="p">)</span>

    <span class="c1"># Bandpass filter</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">freq_rem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq_rem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Calculate the negative product of LOC and ROC, maximal during REM.</span>
    <span class="n">negp</span> <span class="o">=</span> <span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Find peaks in data</span>
    <span class="c1"># - height: required height of peaks (min and max.)</span>
    <span class="c1"># - distance: required distance in samples between neighboring peaks.</span>
    <span class="c1"># - prominence: required prominence of peaks.</span>
    <span class="c1"># - wlen: limit search for bases to a specific window.</span>
    <span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span> <span class="o">=</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">pks</span><span class="p">,</span> <span class="n">pks_params</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">negp</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="p">(</span><span class="n">hmin</span><span class="p">,</span> <span class="n">hmax</span><span class="p">),</span>
                                        <span class="n">distance</span><span class="o">=</span><span class="p">(</span><span class="n">duration</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">),</span>
                                        <span class="n">prominence</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">hmin</span><span class="p">),</span>
                                        <span class="n">wlen</span><span class="o">=</span><span class="p">(</span><span class="n">duration</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sf</span><span class="p">))</span>

    <span class="c1"># Intersect with sleep stage vector</span>
    <span class="c1"># We do that before calculating the features in order to gain some time</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">hypno</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>
        <span class="n">idx_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pks</span><span class="p">,</span> <span class="n">idx_good</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">pks</span><span class="p">,</span> <span class="n">idx_mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pks_params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">pks_params</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">idx_good</span><span class="p">]</span>

    <span class="c1"># If no peaks are detected, return None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No REMs were found in data. Returning None.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Hypnogram</span>
    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># The sleep stage at the beginning of the REM is considered.</span>
        <span class="n">rem_sta</span> <span class="o">=</span> <span class="n">hypno</span><span class="p">[</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rem_sta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">pks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Calculate time features</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Peak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;End&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Start&#39;</span><span class="p">]</span>
    <span class="c1"># Time points in minutes (HH:MM:SS)</span>
    <span class="c1"># pks_params[&#39;StartMin&#39;] = pd.to_timedelta(pks_params[&#39;Start&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># pks_params[&#39;PeakMin&#39;] = pd.to_timedelta(pks_params[&#39;Peak&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># pks_params[&#39;EndMin&#39;] = pd.to_timedelta(pks_params[&#39;End&#39;], unit=&#39;s&#39;).dt.round(&#39;s&#39;)  # noqa</span>
    <span class="c1"># Absolute LOC / ROC value at peak (filtered)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span>
    <span class="c1"># Absolute rising and falling slope</span>
    <span class="n">dist_pk_left</span> <span class="o">=</span> <span class="p">(</span><span class="n">pks</span> <span class="o">-</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">dist_pk_right</span> <span class="o">=</span> <span class="p">(</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">pks</span><span class="p">)</span> <span class="o">/</span> <span class="n">sf</span>
    <span class="n">locrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">dist_pk_left</span>
    <span class="n">rocrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">dist_pk_left</span>
    <span class="n">locfs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist_pk_right</span>
    <span class="n">rocfs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist_pk_right</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">locrs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rocrs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">locfs</span><span class="p">)</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rocfs</span><span class="p">)</span>
    <span class="c1"># Sleep stage</span>
    <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rem_sta</span>

    <span class="c1"># Convert to Pandas DataFrame</span>
    <span class="n">df_rem</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pks_params</span><span class="p">)</span>

    <span class="c1"># Make sure that the sign of ROC and LOC is opposite</span>
    <span class="n">df_rem</span><span class="p">[</span><span class="s1">&#39;IsOppositeSign&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span>
    <span class="n">df_rem</span> <span class="o">=</span> <span class="n">df_rem</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pks</span><span class="p">])</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pks</span><span class="p">])]</span>

    <span class="c1"># Remove bad duration</span>
    <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">duration</span>
    <span class="n">good_dur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tmin</span><span class="p">,</span>
                              <span class="n">pks_params</span><span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tmax</span><span class="p">)</span>
    <span class="n">df_rem</span> <span class="o">=</span> <span class="n">df_rem</span><span class="p">[</span><span class="n">good_dur</span><span class="p">]</span>

    <span class="c1"># Keep only useful channels</span>
    <span class="n">df_rem</span> <span class="o">=</span> <span class="n">df_rem</span><span class="p">[[</span><span class="s1">&#39;Start&#39;</span><span class="p">,</span> <span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="s1">&#39;End&#39;</span><span class="p">,</span> <span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;Stage&#39;</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">hypno</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df_rem</span> <span class="o">=</span> <span class="n">df_rem</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df_rem</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_rem</span><span class="p">[</span><span class="s1">&#39;Stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

    <span class="c1"># We need at least 100 detected REMs to apply the Isolation Forest.</span>
    <span class="k">if</span> <span class="n">remove_outliers</span> <span class="ow">and</span> <span class="n">df_rem</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">IsolationForest</span>
        <span class="n">col_keep</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Duration&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsValPeak&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsValPeak&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;LOCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;ROCAbsRiseSlope&#39;</span><span class="p">,</span> <span class="s1">&#39;LOCAbsFallSlope&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;ROCAbsFallSlope&#39;</span><span class="p">]</span>
        <span class="n">ilf</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">max_samples</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">ilf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">df_rem</span><span class="p">[</span><span class="n">col_keep</span><span class="p">])</span>
        <span class="n">good</span><span class="p">[</span><span class="n">good</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> outliers were removed.&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="c1"># Remove outliers from DataFrame</span>
        <span class="n">df_rem</span> <span class="o">=</span> <span class="n">df_rem</span><span class="p">[</span><span class="n">good</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> REMs were found in data.&#39;</span><span class="p">,</span> <span class="n">df_rem</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">df_rem</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-2020, Raphael Vallat.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>